<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">Tian</title>
    <subtitle type="html">TianPingan想做一个努力的人</subtitle>
    <updated>2021-04-04T10:31:16&#43;08:00</updated>
    <id>https://tianpingan.github.io/</id>
    <link rel="alternate" type="text/html" href="https://tianpingan.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://tianpingan.github.io/atom.xml" />
    <author>
            <name>TianPingan</name>
            <uri>https://tianpingan.github.io/</uri>
            
                <email>tianpingan2000@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.81.0">Hugo</generator>
        <entry>
            <title type="text">Test_2</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/test_2/" />
            <id>https://tianpingan.github.io/posts/test_2/</id>
            <updated>2021-04-04T10:17:56&#43;08:00</updated>
            <published>2021-04-04T10:17:37&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;这是测试&lt;/p&gt;
&lt;p&gt;$hello$&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">ComputerConstruct_meeting</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/computerconstruct_meeting/" />
            <id>https://tianpingan.github.io/posts/computerconstruct_meeting/</id>
            <updated>2021-04-04T10:29:31&#43;08:00</updated>
            <published>2021-03-09T17:41:33&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&#34;第一章计算机系统概述&#34;&gt;第一章、计算机系统概述&lt;/h3&gt;
&lt;h3 id=&#34;1计算机发展历程&#34;&gt;1.计算机发展历程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;计算机硬件发展历程&lt;/strong&gt;：
电子管时代--&amp;gt;晶体管时代--&amp;gt;中小规模集成电路时代--&amp;gt;超大规模集成电路时代--&amp;gt;智能计算机--&amp;gt;生物计算机和量子计算机。
&lt;strong&gt;计算机的分类&lt;/strong&gt;：
专用计算机、通用计算机。
&lt;strong&gt;摩尔定律&lt;/strong&gt;：
当价格不变时，集成电路上可容纳的元器件的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍。揭示了信息技术进步的速度。
&lt;strong&gt;其他&lt;/strong&gt;：操作系统直接影响计算机系统性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2计算机系统层次结构&#34;&gt;2.计算机系统层次结构&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;计算机系统=硬件+软件=（中央处理器、存储器和外部设备等）+（计算机的运行程序和相应的文档）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;21-计算机硬件的基本组成&#34;&gt;2.1 计算机硬件的基本组成&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;存储器&lt;/strong&gt;：分为主存储器（内存储器）和辅助存储器（外存储器）。主存储器存放重程序和数据，辅助存储器中的信息必须调入主存后才能被CPU访问。
(2)&lt;strong&gt;运算器&lt;/strong&gt;：主要功能时进行算术运算和逻辑运算，核心是算数逻辑单元（ALU）。运算器包含若干通用寄存器。
(3)&lt;strong&gt;控制器&lt;/strong&gt;：计算机的指挥中心。由&lt;code&gt;程序计数器（PC）&lt;/code&gt;、&lt;code&gt;指令寄存器（IR）&lt;/code&gt;和&lt;code&gt;控制单元（CU）&lt;/code&gt;组成。
(4)输入设备。
(5)输出设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-计算机软件的分类&#34;&gt;2.2 计算机软件的分类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）系统软件；
（2）应用软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;23-计算机编程语言分类&#34;&gt;2.3 计算机编程语言分类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;机器语言、汇编语言、高级语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;24-编译程序与解释程序的区别&#34;&gt;2.4 编译程序与解释程序的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;编译程序生成目标代码，而解释程序不生成；编译程序产生目标代码的执行速度比解释程序的执行速度快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;25-计算机的工作过程&#34;&gt;2.5 计算机的工作过程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不断地从存储器中逐条取出指令，然后送至控制器，经分析后由CPU发出各种操作命令，指挥各部件完成各种操作，直至程序中全部指令执行结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;26-计算机系统的层次结构&#34;&gt;2.6 计算机系统的层次结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)第1级。微程序机器级。微指令由硬件直接执行。
(2)第2级。传统机器级(机器语言)。用微程序解释指令系统。
(3)第3级。操作系统级。用机器语言解释作业控制语句；
(4)第4级。汇编语言机器级。用汇编程序翻译成汇编语言程序；
(5)第5级。高级语言机器级。用编译程序翻译成汇编程序或直接翻译成机器语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3计算机性能指标&#34;&gt;3.计算机性能指标&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;吞吐量&lt;/strong&gt;：单位时间内的数据处理量，主要取决于主存的存取周期；
(2)&lt;strong&gt;响应时间&lt;/strong&gt;：从提交作业到该作业得到CPU响应所经理的时间。响应时间越短，吞吐量越大。
(3)&lt;strong&gt;主频&lt;/strong&gt;：机器内部主时钟的频率，衡量机器速度；
(4)&lt;strong&gt;CPU周期&lt;/strong&gt;：又称机器周期，指的是从内存读取一条指令字的最短时间。一个指令周期由若干个CPU周期构成；
(5)&lt;strong&gt;CPU时钟周期&lt;/strong&gt;：主频的倒数，是CPU中最小的时间单位。
(6)&lt;strong&gt;CPI、MIPS、FLOPS&lt;/strong&gt;；
(7)&lt;strong&gt;CPU执行时间&lt;/strong&gt;：CPU对某特定程序的执行时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第三章存储器层次结构&#34;&gt;第三章、存储器层次结构&lt;/h2&gt;
&lt;h3 id=&#34;1-存储器的分类&#34;&gt;1. 存储器的分类&lt;/h3&gt;
&lt;p&gt;存储器=主存储器+高速缓冲存储器（Cache）+辅助存储器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)按照&lt;strong&gt;存储介质&lt;/strong&gt;可分为：
1)&lt;code&gt;半导体存储器&lt;/code&gt;：包括随机存储器和只读存储器两类（RAM和ROM）；
2)&lt;code&gt;磁表面存储器&lt;/code&gt;：包括磁盘、磁带，使用顺序存取方式；
3)&lt;code&gt;光盘存储器&lt;/code&gt;：也叫光存储器，一般指光盘；
4)&lt;code&gt;磁心存储器&lt;/code&gt;：由各种磁心制成，目前已被半导体存储器取代。
(2)按&lt;strong&gt;存取方式&lt;/strong&gt;可分为：
1)&lt;code&gt;随机存取存储器（RAM）&lt;/code&gt;：可存可取，存取时间和存取位置没有关系。
优点：读写方便，使用灵活；
缺点：断电信息丢失。
分为静态RAM（SRAM，常用作高速缓冲存储器）和动态RAM（DRAM常用作主存）
2)&lt;code&gt;只读存储器（ROM）&lt;/code&gt;：只可取，一般把一些固定的、不变的程序存放在这里，其内容断电后仍可保留。
3)&lt;code&gt;串行访问存储器&lt;/code&gt;：在对存储单元进行读写操作时，需要按照物理位置的先后顺序依次访问，主要包括顺序存取存储器（磁带）和直接存取存储器（磁盘，半串行，因为要先寻道）。
(3)按照&lt;strong&gt;在计算机中的作用&lt;/strong&gt;可分为：
1）主存储器；
2)辅助存储器；
3)缓冲存储器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2存储器的性能指标&#34;&gt;2.存储器的性能指标&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)存储容量=存储字数(表示存储器的地址空间大小即存储器的存储单元数目)*字长(存储字长，表示一次存取操作的数据量);
(2)单位成本：每位价格=总成本/总容量；
(3)存储速度：数据传输率=数据的宽度/存储周期（ 存储周期又称读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3存储周期与存取时间的区别&#34;&gt;3.存储周期与存取时间的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;存储周期又称读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔，而存取时间是指启动一次存储器操作到完成该操作所经历的时间，一般小于存储周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4存储器的层次化结构&#34;&gt;4.存储器的层次化结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;缓存-主存层次&lt;/strong&gt;主要解决CPU和主存速度不匹配的问题。主存和缓存之间的数据交换是由硬件自动完成的，对程序员是透明的；
&lt;strong&gt;主存-辅存层次&lt;/strong&gt;主要解决层次系统的容量问题。主存和辅存之间的数据交换是由硬件和操作系统共同完成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-半导体随机存取存储器&#34;&gt;5. 半导体随机存取存储器&lt;/h3&gt;
&lt;h3 id=&#34;51-半导体存储芯片的基本结构&#34;&gt;5.1 半导体存储芯片的基本结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;半导体存储芯片主要由存储矩阵、译码驱动电路和读/写电路组成。
地址线是单向的，数据线是双向的，其余的属于控制线，包括读/写控制线（用来进行读/写操作）和片选线（用来选择存储芯片）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;52-半导体存储芯片的译码驱动方式&#34;&gt;5.2 半导体存储芯片的译码驱动方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;译码驱动：将地址线送来的地址信号转换成对应存储单元的选择信号。
(1)&lt;strong&gt;线选法&lt;/strong&gt;（单译码）：矩阵有N行，则需要地址线$log_2N$根；矩阵每行有m位(也就是m列)，则需要m根数据线；
(2)*&lt;strong&gt;重合法&lt;/strong&gt;（双译码）：同时需要行和列的地址线。32($2^5$)行里选中1行需要5根地址线，32($2^5$)列选中一列也需要5根地址线，一共需要10根地址线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;53-静态ramsram存储器&#34;&gt;5.3 静态RAM（SRAM）存储器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;存储器的工作：保持存储信息、读数据和写数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;54-动态ramdram存储器&#34;&gt;5.4 动态RAM（DRAM）存储器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;存储器的工作：保持存储信息、读数据和写数据
DRAM存储器的刷新：采用电容式存储，按行刷新(因为存储体是矩阵形式)，由硬件支持，不由CPU指挥，占一个读/写周期。
3种&lt;strong&gt;刷新方式&lt;/strong&gt;：
1)集中刷新：把刷新操作集中到一段时间内进行；
2)分散刷新：将刷新操作分散进行，周期性的进行；
3)异步刷新：是一个折中方案，有计划的刷新，时间分配十分合理。
刷新的实质：读出后再按原样写入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;55-只读存储器rom&#34;&gt;5.5 只读存储器（ROM）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可分为：
掩膜型只读存储器(MROM)、可编程只读存储器(PROM)、可擦除可编程存储器(EPROM)、电可擦除可编程存储器(EEPROM)、快擦除读写存储器(Flash Memory，又叫闪存，集合了ROM和RAM的长处)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;56-对比rom和ram&#34;&gt;5.6 对比ROM和RAM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;存取方式一样，都是随机存取。不同的是，ROM只读，RAM可读可写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;57-存储器容量扩充&#34;&gt;5.7 存储器容量扩充&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：将若干个存储芯片连接在一起组成足够容量的存储器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充求芯片数量的公式&lt;/strong&gt;：若要求将容量为&lt;code&gt;a*b（a为字线，连接地址线）&lt;/code&gt;的芯片组成容量为&lt;code&gt;c*d&lt;/code&gt;的芯片，则协议的芯片数量&lt;code&gt;n=(c*d)/a*b（整个存储器的容量除以单个芯片的容量）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3类&lt;strong&gt;扩充方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1)位扩充（增加&lt;code&gt;a*b中的b&lt;/code&gt;）：
增加存储字长，横向扩展，比如要将&lt;code&gt;1K*4&lt;/code&gt;位的芯片组成&lt;code&gt;1K*8&lt;/code&gt;位的存储器，过程如下：需要&lt;code&gt;（1K*8）/（1K*4）=2&lt;/code&gt;片芯片，需要10根地址线（$2^{10}=1K$），需要8根数据线（&lt;code&gt;1K*8&lt;/code&gt;中的8代表位数）；&lt;/p&gt;
&lt;p&gt;2)字扩充（增加&lt;code&gt;a*b中的a&lt;/code&gt;）：
增加存储单元的个数，纵向扩展，比如要将&lt;code&gt;1K*8&lt;/code&gt;位的芯片组成&lt;code&gt;2K*8&lt;/code&gt;位的存储器，过程如下：需要&lt;code&gt;（2K*8）/（1K*8）=2&lt;/code&gt;片芯片，需要11根地址线（$2^{11}=2K$），需要8根数据线（&lt;code&gt;2K*8&lt;/code&gt;中的8代表位数）；&lt;/p&gt;
&lt;p&gt;3）字位扩充（增加&lt;code&gt;a*b中的a和b&lt;/code&gt;）：
增加存储单元的个数和存储字长，纵向扩展，比如要将&lt;code&gt;1K*4&lt;/code&gt;位的芯片组成&lt;code&gt;4K*8&lt;/code&gt;位的存储器，过程如下：需要&lt;code&gt;（4K*8）/（1K*4）=8&lt;/code&gt;片芯片，需要11根地址线（$2^{12}=4K$），需要8根数据线（&lt;code&gt;2K*8&lt;/code&gt;中的8代表位数）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-双口ram&#34;&gt;6. 双口RAM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;具有两组相互独立的地址线、数据线和读/写控制线。
可以并行工作，是一种高速工作的存储器；
有可能在同一时间两个端口同时操作存储器的同一个存储单元，因此设置了&lt;code&gt;BUSY&lt;/code&gt;标志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-多模块存储器解决了cpu与io设备速度不匹配的问题提高了存储器的工作速度&#34;&gt;7. 多模块存储器（解决了CPU与I/O设备速度不匹配的问题，提高了存储器的工作速度）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不同于寻找更高速的元件和采用存储器层次结构，这种方法是通过调整主存的结构来提高访存速度，主要有两类：单体多字存储器、多体并行存储器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;71-单体多字存储器&#34;&gt;7.1 单体多字存储器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用前提&lt;/strong&gt;：指令和数据在主存内必须连续存放；
&lt;strong&gt;原理&lt;/strong&gt;：把存储器的&lt;code&gt;存储字&lt;/code&gt;字长增加n倍，以存放n个指令字或数据字，于是单体多字存储器的最大带宽比单体单字存储器的最大带宽提高n倍。正常情况下不可能达到最大带宽，因为程序使用指令字和数据字存在随机性。；
&lt;strong&gt;缺点&lt;/strong&gt;：必须凑齐n个数据字之后才能作为一个存储字一次写入存储器，因此需要首先把属于一个存储字的n个数据字读入到数据寄存器中，等数据寄存器达到了一个存储字的长度，再将其写入存储器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;72-多体并行存储器&#34;&gt;7.2 多体并行存储器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓多体并行存储器，就是采用多个模块组成的存储器，每个模块有着相同的容量和存取速度，各个模块都有独立的地址寄存器、数据寄存器、地址译码器和读/写电路，每个模块都可以看做一个独立的存储器。
主要分为两种：高位交叉编址的多体并行存储器、低位交叉编址的多体并行存储器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;721-高位交叉编址的多体并行存储器竖着走按列扫描&#34;&gt;7.2.1 高位交叉编址的多体并行存储器(竖着走，按列扫描)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;高位地址表示体号，低位地址定位体内地址。由于每个模块内的体内地址顺序是连续的，因此又称&lt;code&gt;顺序存储&lt;/code&gt;。这样，可以在同一时间使得不同的请求源同时访问不同的体，进而实现个体的并行工作。
&lt;strong&gt;特点&lt;/strong&gt;：相邻两个字在同一个存储体中，高位的变动才会产生交叉访问的效果。
&lt;strong&gt;优点&lt;/strong&gt;：非常有利于存储器的扩充，只需将存储单元的编号往后加即可。
&lt;strong&gt;缺点&lt;/strong&gt;：由于各个模块一个接一个的串行工作，因此存储器的带宽受到了限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;722-低位交叉编址的多体并行存储器横着走按行扫描&#34;&gt;7.2.2 低位交叉编址的多体并行存储器(横着走，按行扫描)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;由于程序是存放在相邻的体中，因此又称&lt;code&gt;交叉存储&lt;/code&gt;。低位为体号，高位定位体内地址。
&lt;strong&gt;特点&lt;/strong&gt;：连续地址分布在相邻的不同模块内，而同一个模块内的地址都是不连续的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-高速缓冲存储器cache--提高存储系统的工作速度&#34;&gt;8. 高速缓冲存储器（Cache）--提高存储系统的工作速度&lt;/h3&gt;
&lt;h3 id=&#34;81-主存和cache的编址&#34;&gt;8.1 主存和Cache的编址&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;主存由一个个的字块组成，主存的地址分为两部分：高m位表示主存的块地址，低b位表示其块内的字或字节。同理，Cache的地址也应分为两部分：高ｃ位表示Cache的块号，低ｂ位表示其块内的字或字节数。
&lt;strong&gt;命中率&lt;/strong&gt;：CPU要访问的的信息在Cache中的比例；
&lt;strong&gt;平均访问时间&lt;/strong&gt;：假设命中率为$h$，$t_c$为命中时访问Cache的时间，$t_m$为未命中时的主存访问时间，则Cache-主存系统的平均访问时间$t_a$为$t_a=ht_c+(1-h)t_m$；
&lt;strong&gt;Cache-主存系统效率&lt;/strong&gt;：$e=t_c/t_a$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Cache的命中率只与&lt;code&gt;Cache的容量&lt;/code&gt;、&lt;code&gt;Cache的字块长度&lt;/code&gt;有关。&lt;/li&gt;
&lt;li&gt;主存与Cache之间传送数据的基本单位是块，而主存与CPU之间传送数据的基本单位是字（一个块包含多个字）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;82-cache的基本结构&#34;&gt;8.2 Cache的基本结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;地址映射变换机构(将CPU送来的主存地址转换成Cache地址)；
替换机构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;83-指令和数据是放在同一个cache中吗&#34;&gt;8.3 指令和数据是放在同一个Cache中吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一级Cache的指令和数据一般分开存放，而二级Cache的指令和数据放在一起，因此有&lt;code&gt;L1 data Cache&lt;/code&gt;和&lt;code&gt;L1 code Cache&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-一些其他知识点&#34;&gt;8.4 一些其他知识点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在CPU和主存之间增加Cache并不能增加计算机总存储量；
程序员无需知道高速缓存的访问过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-cache和主存之间的映射方式主存块号--cpu块号&#34;&gt;9. Cache和主存之间的映射方式(主存块号--&amp;gt;CPU块号)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;直接映射&lt;/strong&gt;：每个缓存块可以和若干个主存块对应，每个主存块只能和一个缓存块对应。
优点：实现简单。
缺点：不够灵活(容易造成空闲Cache块的浪费)、冲突概率高(抖动)。
应用场合：适合大容量Cache。
(2)&lt;strong&gt;全相联映射&lt;/strong&gt;：主存中每一个字块可以映射到Cache中的任何一块。
优点：Cache的命中率提高了、减小了块的冲突率(空位随便坐)进而提高了Cache的利用率。
缺点：tag的位数增加了，访问Cache时主存字块标记需要和Cache的全部“标记”进行比较，才能判断所访问主存地址是否已在Cache内。
应用场合：适用于小容量的Cache。
(3)&lt;strong&gt;组相联映射&lt;/strong&gt;：按号分组，组内随意放(把Cache分成Q组，每组有R块)，这样，组间是直接映射，组内是全相联映射，虽没有直接相连的速度快，但电路实现简单(只需进行组间本比较，而无需&lt;code&gt;对Cache的每一块进行比较[全相联是这样子的，它需要]&lt;/code&gt;)，命中率高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10cache中主存块的替换算法针对全相联和组相联至于直接映射只需直接替换就好了&#34;&gt;10.Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;先进先出，近期最少使用(理想，预测性，难以实现)，最不经常使用，随机法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-cache写操作策略同步cache块与主存块中的内容&#34;&gt;11. Cache写操作策略（同步Cache块与主存块中的内容）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;写回法&lt;/strong&gt;：
当CPU写Cache命中时，只修改Cache的内容，而不立即写入主存，只有当此行被换出时才写回主存。这样减少了访存次数。Cache的每一行都设置一个修改位(脏位)，当某行被换出时，根据此行的修改位来决定将该行内容写回主存还是简单丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若未命中，则使用&lt;code&gt;写分配法&lt;/code&gt;：加载主存中的块到Cache中，然后在Cache中更新，最后同步到主存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(2)&lt;strong&gt;全写法&lt;/strong&gt;：
当写Cache命中时，Cache与主存同时发生写修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若未命中，则使用&lt;code&gt;非写分配法&lt;/code&gt;：只写入主存而不调入Cache。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(3)&lt;strong&gt;写一次法&lt;/strong&gt;：
以上两种方法的折中，写命中与写未命中的处理方法与写回法基本一致，仅仅是第一次写命中时要同时写入主存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-虚拟存储器&#34;&gt;12. 虚拟存储器&lt;/h3&gt;
&lt;p&gt;详见操作系统。&lt;/p&gt;
&lt;h2 id=&#34;第四章指令系统&#34;&gt;第四章、指令系统&lt;/h2&gt;
&lt;h3 id=&#34;1-指令概述&#34;&gt;1. 指令概述&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;构成机器语言的一条条语句就是一条条&lt;strong&gt;机器指令&lt;/strong&gt;，全部机器指令的集合就是&lt;strong&gt;机器的指令系统&lt;/strong&gt;。
一条指令包括&lt;code&gt;操作码&lt;/code&gt;和&lt;code&gt;地址码&lt;/code&gt;两部分：
&lt;strong&gt;操作码&lt;/strong&gt;：分为&lt;code&gt;定长操作码&lt;/code&gt;和&lt;code&gt;不定长操作码&lt;/code&gt;。告诉要做什么操作（比如，加减乘除）；
&lt;strong&gt;地址码&lt;/strong&gt;：又称&lt;code&gt;操作数字段&lt;/code&gt;，其任务是：指出操作数的地址、运算结果需存放的地址、下一条指令的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-指令分类&#34;&gt;2. 指令分类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;零地址指令&lt;/strong&gt;：只给出操作码字段OP，适用于：1）不需要操作数的指令，比如停机指令、关中断指令等；2）堆栈计算机中的零地址运算类指令。
(2)&lt;strong&gt;一地址指令&lt;/strong&gt;：地址码字段只有一个，适用于：1）单目运算，如求反，减一等；2）隐含约定目的地址的双操作数指令。假设指令字长32位，地址码字段24位，则寻址范围是$2^{24}=16M$
(3)&lt;strong&gt;二地址指令&lt;/strong&gt;：有两个地址码字段，一个是源操作数地址，另一个是目的操作数地址，适用于各类加减乘除运算。假设指令字长32位，操作码8位，两个地址码字段各12位，则寻址范围是$2^{12}=4K$。
(4)&lt;strong&gt;三地址指令&lt;/strong&gt;：有三个地址码字段。假设指令字长32位，操作码8位，三个地址码字段各8位，则寻址范围是$2^8=256$
(5)&lt;strong&gt;四地址指令&lt;/strong&gt;：有四个地址码字段。若指令字长32位，操作码8位，4个地址码各6位，则直接寻址范围是$2^6==64$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;指令字长取决于操作码的长度、操作数地址的长度、操作数地址的个数。
每一条指令指令都必须告诉CPU该指令如何做，因此必须指定操作码。&lt;/p&gt;
&lt;h3 id=&#34;3什么是指令字长&#34;&gt;3.什么是指令字长&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;指令字长是指一条指令所占用存储空间的大小。指令字长一般为字节的整数倍。
单字长指令：指令长度=机器字长；
半字长指令：指令长度=0.5&lt;em&gt;机器字长；&lt;/em&gt;
&lt;em&gt;双字长指令：指令长度=2&lt;/em&gt;机器字长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4区分数据字和指令字&#34;&gt;4.区分数据字和指令字&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果计算机中的某一个字表示的是一个数据，则此字称为&lt;code&gt;数据字&lt;/code&gt;；
如果计算机中的某一个字表示的是一条指令，则此字就称为&lt;code&gt;指令字&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-定长操作码和不定长操作码&#34;&gt;5. 定长操作码和不定长操作码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定长操作码&lt;/strong&gt;：在指令字的最高位部分分配固定的若干位表示操作码。对于具有n位操作码字段的指令系统，最多能够表示$2^n$条指令。
&lt;strong&gt;不定长操作码&lt;/strong&gt;：操作码的长度随地址码个数的减少而增加，不同的地址数的指令可以具有不同长度的操作码。这样子可以在满足需要的前提下有效的缩指令字长。需要注意的是：不允许较短的操作码是较长的操作码的前缀；各条指令的操作码一定不可以重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6指令的寻址方式&#34;&gt;6.指令的寻址方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;定义：是指指令或操作数有效地址的寻找方式，主要分为&lt;code&gt;数据寻址&lt;/code&gt;和&lt;code&gt;指令寻址&lt;/code&gt;。
寻址的原因：因为指令的地址码字段往往并不是操作数的真实地址，而是形式地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;61-指令寻址和数据寻址的比较&#34;&gt;6.1 指令寻址和数据寻址的比较&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;确定指令存放位置的过程称为&lt;code&gt;指令寻址方式&lt;/code&gt;，确定操作数存放位置的过程称为&lt;code&gt;数据寻址方式&lt;/code&gt;，两者复杂度不一样。
&lt;strong&gt;指令寻址&lt;/strong&gt;是指找到下一条将要执行的指令的地址，有两种方式：顺序执行(用指令计数器(PC)+1来得到下一条在指令的地址)和跳转执行(通过转移指令的寻址方式，计算出目标地址，送到PC中即可。目标转移地址的形成方式主要有3种：立即寻址(直接地址)、相对寻址(相对地址)、间接寻址(间接地址))。
&lt;strong&gt;数据寻址&lt;/strong&gt;是指找到当前正在执行指令的数据地址。为了区分各种数据寻址方式，通常在指令字中设置一个字段，用来致命使用何种寻址方式，这样，数据指令字的结构变为{操作码，寻址特征，形式地址(A)}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;62常见的数据寻址方式&#34;&gt;6.2常见的数据寻址方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;立即寻址&lt;/strong&gt;：立即给出操作数，不需要给出地址去其他地方找操作数。只需要在取指令时访问存储器，而在执行阶段不需要。但A的位数限制了立即寻址的范围。常用于对某寄存器或内存单元赋初值。&lt;/p&gt;
&lt;p&gt;(2)&lt;strong&gt;直接寻址&lt;/strong&gt;：通过指令中的地址码字段找到真实地址(取货码取快递)，执行阶段需要访问一次存储器去取操作数。直接给出了操作数的有效地址，寻找操作数简单，但是寻址范围较小(操作数的有效地址仅由A决定，而A的位数一般都比较小，因此寻址范围比较小)。&lt;/p&gt;
&lt;p&gt;(3)&lt;strong&gt;隐含寻址&lt;/strong&gt;：指令字不明显的给出操作数的地址，其操作数地址隐含在操作码或者某个寄存器中。有利于缩短指令字长，但是需要增加存储操作数或隐含地址的硬件。&lt;/p&gt;
&lt;p&gt;(4)&lt;strong&gt;间接寻址&lt;/strong&gt;：解决了直接寻址的寻址范围小的问题。直接寻址直接给出了操作数的有效地址，而间接寻址给出的是&lt;code&gt;操作数有效地址的地址&lt;/code&gt;。间接寻址又可以分为&lt;code&gt;一次间接寻址&lt;/code&gt;和&lt;code&gt;多次间接寻址&lt;/code&gt;。便于子程序返回和查表，但N次间接寻址需要在指令阶段还需要访问存储器&lt;code&gt;N+1&lt;/code&gt;次(前N次找操作数的有效地址，最后一次找操作数)。&lt;/p&gt;
&lt;p&gt;(5)&lt;strong&gt;寄存器寻址&lt;/strong&gt;：和直接寻址类似，在直接寻址的指令字中，地址码字段给出的是主存地址，而在寄存器寻址的指令字中，地址码字段直接给出的是寄存器编号$R_i$，则操作数的有效地址为$EA=R_i$。
(6)&lt;strong&gt;寄存器间接寻址&lt;/strong&gt;：和寄存器寻址不同之处在于，$R_i$中存放的不是操作数，而是操作数所在主存单元的地址号，有效地址$EA=(R_i)$。便于编制循环程序，但需要访问一次存储器去取操作数。&lt;/p&gt;
&lt;p&gt;(7)&lt;strong&gt;基址寻址&lt;/strong&gt;：设置一个基址寄存器(BR)，则其操作数的有效地址等于指令字中的形式地址A与基址寄存器中的内容(基地址)相加，即：$EA=A+(BR)$。扩大了操作数的寻址范围(因为基址寄存器的位数可以大于形式地址Ade位数)，便于解决多道程序问题。注意：基址寄存器的内容由操作系统确定，但用户有权知道使用了哪个寄存器作为基址寄存器。&lt;/p&gt;
&lt;p&gt;(8)&lt;strong&gt;变址寻址&lt;/strong&gt;：不同于基址寻址，在变址寻址中，变址寄存器中的内容由用户设定，在程序执行过程中其值可变，而指令字中的形式地址A是不可变的。也扩大了操作数的寻址范围，非常适合处理数组和循环问题。&lt;/p&gt;
&lt;p&gt;(9)&lt;strong&gt;相对寻址&lt;/strong&gt;：基于程序局部性原理，相对寻址的有效地址是将程序计数器(PC)的内容与指令字中的形式地址A相加而成，即：$EA=(PC)+A$。用于转移类指令，便与编制浮动程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-circ和risc的基本概念&#34;&gt;7. CIRC和RISC的基本概念&lt;/h3&gt;
&lt;h3 id=&#34;71-cisc的主要特点&#34;&gt;7.1 CISC的主要特点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1) 指令系统复杂庞大；
(2)指令长度不固定，指令格式种类多，寻址方式种类多；
(3)可以访存的指令不受限制(RISC只有取数/存数指令访问存储器)；
(4)由于80%的程序只是用20%的指令，因此CISC各指令的使用频率差距太大；
(5)各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成；
(6)控制器大多数采用微程序控制；
(7)难以用优化编译生成高效的目标代码程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;72-80-20定律&#34;&gt;7.2 80-20定律&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;典型程序中80%的语句都是使用计算机中20%的指令，而这20%的指令都属于简单指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是&lt;code&gt;RISC&lt;/code&gt;出现了！&lt;/p&gt;
&lt;h3 id=&#34;73-risc的主要特点&#34;&gt;7.3 RISC的主要特点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)把复杂指令的功能用使用频率较高的简单指令实现；
(2)指令长度固定，指令格式种类少，寻址方式种类少；
(3)只有取数/存数指令访问存储器，其余的指令操作在寄存器中完成；
(4)CPU中有多个通用寄存器(比CISC的多)；
(5)一定采用流水线技术，大部分指令在一个时钟周期内完成；
(6)控制器采用组合逻辑控制，不用微程序控制；
(7)采用优化的编译程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;74-对比risc和cisc&#34;&gt;7.4 对比RISC和CISC&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;RISC更能提高计算机的运算速度，更便于设计，可降低成本，提高可靠性，更有效支持高级语言程序。而CISC有专用指令来完成特定的更能，因此处理特殊任务比较高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第五章中央处理器&#34;&gt;第五章、中央处理器&lt;/h2&gt;
&lt;h3 id=&#34;1-序言&#34;&gt;1. 序言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU=运算器+控制器。
运算器的功能是对数据进行加工；
控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令、执行指令、控制主机与I/O设备交换信息以及总线的管理，处理中断的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-cpu的功能&#34;&gt;2. CPU的功能&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中，称为&lt;code&gt;指令控制&lt;/code&gt;；
(2)取到指令之后，应该产生完成每条指令所需要的控制命令，称为&lt;code&gt;操作控制&lt;/code&gt;；
(3)控制命令产生后，需要对各种控制命令加以时间上的控制，称为&lt;code&gt;时间控制&lt;/code&gt;；
(4)在执行的过程中，可能需要进行算术运算和逻辑运算，称为&lt;code&gt;数据加工&lt;/code&gt;；
(5)最后当然还有处理中断的能力，称为&lt;code&gt;中断处理&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-cpu的基本结构&#34;&gt;3. CPU的基本结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;控制单元(CU)&lt;/strong&gt;：指令控制、操作控制、 时间控制；
&lt;strong&gt;算数逻辑单元(ALU)&lt;/strong&gt;：数据加工；
&lt;strong&gt;中断系统&lt;/strong&gt;：中断处理；
&lt;strong&gt;寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-cpu中的主要寄存器&#34;&gt;4. CPU中的主要寄存器&lt;/h3&gt;
&lt;p&gt;可分为&lt;code&gt;运算器中的寄存器&lt;/code&gt;和&lt;code&gt;控制器中的寄存器&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;41-运算器中的寄存器&#34;&gt;4.1 运算器中的寄存器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;暂存寄存器&lt;/strong&gt;：暂存从主存读来的数据，对程序员透明(用户不可见)；
(2)&lt;strong&gt;累加寄存器(ACC)&lt;/strong&gt;：是一个通用寄存器，用户可见，暂时存放ALU运算的结果信息，至少要有一个；
(3)&lt;strong&gt;通用寄存器组&lt;/strong&gt;：存放操作数和各种地址信息，用户可见；
(4)&lt;strong&gt;状态条件寄存器(PSW)&lt;/strong&gt;：保存由算数指令和逻辑指令运行或测试的结果建立的各种条件码内容，用户可见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-控制器中的寄存器&#34;&gt;4.2 控制器中的寄存器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;程序计数器(PC)&lt;/strong&gt;：确定下一条指令的地址，具有寄存信息和计数两种功能；
(2)&lt;strong&gt;指令寄存器(IR)&lt;/strong&gt;：保存当前正在执行的指令，指令划分为操作码和地址码字段，由二进制数字组成；
(3)&lt;strong&gt;存储器数据寄存器(MDR)&lt;/strong&gt;：暂时存放由主存读出的一条指令或一个数据字，可作为CPU、内存和外部设备之间信息传送的中转站，并且补偿三者速度上的差别，此外在单累加结构的运算器中，存储器数据寄存器还可兼作操作数寄存器；
(4)&lt;strong&gt;存储器地址寄存器(MAR)&lt;/strong&gt;：保存当前CPU所访问的内存单元的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-指令周期&#34;&gt;5. 指令周期&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;定义：CPU每取出并执行一条指令所需的全部时间，即CPU完成一条指令的时间，称为&lt;strong&gt;指令周期&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个指令周期=若干个机器周期
一个机器周期=若干个时钟周期&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个完整的指令周期包括：
取指周期(取指令)+间址周期(取地址)+执行周期(存取操作数或结果)+中断周期(存程序断点)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-指令的执行方案&#34;&gt;6. 指令的执行方案&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;【方案1】&lt;strong&gt;单指令周期&lt;/strong&gt;：对所有的指令都选用相同的执行时间来完成，指令之间串行执行，效率低；
【方案2】&lt;strong&gt;多指令周期&lt;/strong&gt;：对不同类型的指令选用不同的执行步骤来完成，指令之间仍串行执行，但可以选用不同个数的时钟周期来完成不同指令的执行过程；
【方案3】&lt;strong&gt;流水线方案&lt;/strong&gt;：指令之间可以并行执行，力争在每个时钟脉冲周期完成一条指令的执行过程(理想情况下)。通过在每一个时钟周期启动一条指令，尽量让多条指令同时运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-信息流&#34;&gt;7. 信息流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;信息流是根据指令要求访问的数据序列，在指令执行的不同阶段，要求访问的数据序列是不同的，而且对于不同的指令，它们的数据流往往也是不同的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-数据通路&#34;&gt;8. 数据通路&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;数据在功能部件之间传送的路径称为&lt;code&gt;数据通路&lt;/code&gt;，它的&lt;strong&gt;功能&lt;/strong&gt;是实现CPU内部的运算器和寄存器，以及寄存器之间的数据交换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;81-数据通路的基本结构的两种方式&#34;&gt;8.1 数据通路的基本结构的两种方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;【方式1】&lt;strong&gt;CPU内部总线方式&lt;/strong&gt;：将所有寄存器的输入端和输出端都连接到一条或多条公共的通路上。包括&lt;code&gt;单总线结构&lt;/code&gt;(连接各部件的总线只有一条)和&lt;code&gt;双总线结构和多总线结构&lt;/code&gt;(CPU中有两条或多条总线，此时数据的传递可以同时进行)。这种结构比较简单，但是数据传输存在较多的冲突现象，性能较低。
【方式2】&lt;strong&gt;专用数据通路方式&lt;/strong&gt;：根据指令执行过程中的数据和地址的流动安排连接线路。避免了使用共享的执行，性能较高，但硬件量较大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;82常见数据通路的数据传送&#34;&gt;8.2常见数据通路的数据传送&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）寄存器之间的数据传送(by CPU内部总线)；
（2）主存与CPU之间的数据传送(by CPU内部总线)；
（3）执行算数或逻辑运算(算数逻辑单元ALU没有内部存储功能，因此执行算数逻辑运算时，要求ALU的两个输入端同时有效)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-控制单元的功能&#34;&gt;9. 控制单元的功能&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)从主存中取出一条指令，并指出下一条指令在主存中的位置；
(2)对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作；
(3)指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10-控制器的控制方式&#34;&gt;10. 控制器的控制方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同步控制方式&lt;/strong&gt;：整个系统的所有控制信号均来自一个统一的时钟信号&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)采用完全统一节拍的机器周期(定长方式)；
(2)采用不同节拍的机器周期(不定长方式)；
(3)采用中央控制和局部控制相结合的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;异步控制方式&lt;/strong&gt;：通过应答方式进行联络，不存在基准时标信号，一般用于主机与I/O设备之间的传送控制，使告诉的主机与慢速的I/O设备可以按照各自的需要设置时序系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联合控制方式&lt;/strong&gt;：折中方案，这种方式对各种不同的指令的微操作大部分采用同步控制方式，小部分采用异步控制方式。&lt;/p&gt;
&lt;h3 id=&#34;11-控制单元cu的设计&#34;&gt;11. 控制单元(CU)的设计&lt;/h3&gt;
&lt;h3 id=&#34;111-两种设计方式的对比&#34;&gt;11.1 两种设计方式的对比&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合逻辑控制(硬布线逻辑控制)&lt;/strong&gt;：控制器处理速度块，但电路庞杂导致难以扩展，制造周期长，不灵活，可维护性差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微程序控制&lt;/strong&gt;:仿照程序设计的方法编制&lt;strong&gt;每个机器指令对应的微程序&lt;/strong&gt;，&lt;strong&gt;每个微程序由若干条微指令构成，各微指令包含若干条微命令&lt;/strong&gt;。扩展单元设计简单，指令添加容易(灵活)，可维护性好，但速度较慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-微程序设计&#34;&gt;11.2 微程序设计&lt;/h3&gt;
&lt;h3 id=&#34;1121-微程序设计的概念&#34;&gt;11.2.1 微程序设计的概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将一条机器指令编写成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作命令。然后把这些微程序存到一个控制存储器中，用寻找用户程序的方法来寻找每个微程序中的微指令。所以逐条执行每一条微指令，也就相应地完成了一条机器指令的全部操作。&lt;strong&gt;每一条机器指令都与一个以操作性质命名的微程序对应。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1122-微程序控制的相关概念&#34;&gt;11.2.2 微程序控制的相关概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微命令与微操作 一条机器指令可以分解成一个&lt;strong&gt;微操作&lt;/strong&gt;序列(不可再分)。&lt;strong&gt;微命令&lt;/strong&gt;是由控制部件向执行部件发出的各种控制命令，是构成控制序列的最小单位。&lt;strong&gt;微命令和微操作一一对应&lt;/strong&gt;，微命令是微操作的控制信号，微操作是微命令的执行过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微指令与微周期 &lt;strong&gt;微指令&lt;/strong&gt;是若干微命令的集合，包含操作控制字段和顺序控制字段。&lt;strong&gt;微周期&lt;/strong&gt;指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存储器和控制存储器 &lt;strong&gt;主存储器&lt;/strong&gt;用于存放程序和数据，在CPU外部，用RAM实现；**控制存储器(CM)**用于存放微操作，在CPU内部，用ROM实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序与微程序 &lt;strong&gt;程序&lt;/strong&gt;是指令的有序集合，用于完成特定的功能；&lt;strong&gt;微程序&lt;/strong&gt;是微指令的有序集合，一条指令的功能由一段&lt;strong&gt;微程序&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1123-微程序控制单元的基本组成&#34;&gt;11.2.3 微程序控制单元的基本组成&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;控制存储器&lt;/strong&gt;：这是微程序控制单元的核心部件，用来存放全部微程序，包含控制地址寄存器(CMAR，存放欲读出的微指令地址)和控制数据寄存器(CMDR,存放从控存中读出的微指令)；
&lt;strong&gt;顺序逻辑&lt;/strong&gt;：用来控制微指令序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1124-微指令的基本格式&#34;&gt;11.2.4 微指令的基本格式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;操作控制字段&lt;/strong&gt;：发出各种控制信号；
&lt;strong&gt;顺序控制字段&lt;/strong&gt;:可指出下地址，以控制微指令序列的执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1125-微指令的编码方式&#34;&gt;11.2.5 微指令的编码方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)直接编码(直接控制)方式：在微指令的微命令字段中每一位都代表一个微命令，不需要译码，因此简单、直观，执行速度快，操作并行性好。但微指令字长过长，造成控制存储器容量极大。&lt;/p&gt;
&lt;p&gt;(2)字段直接编码方式：将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中。缩短了微指令字长，但是要通过译码电路后再发出微命令，比较慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：&lt;code&gt;微指令周期&lt;/code&gt;是指读出微指令的时间+执行该条微指令的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(3)字段间接编码方式：一个字段的某些微命令需由另一个字段中的某些微命令来解释，而不是靠字段直接译码发出微命令。可以进一步缩短微指令字长，但削弱了微指令的并行能力。&lt;/p&gt;
&lt;p&gt;(4)混合编码方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1125-微指令格式&#34;&gt;11.2.5 微指令格式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;水平型微指令&lt;/strong&gt;：一次能定义并执行多个并行操作。&lt;/p&gt;
&lt;p&gt;优点：微程序短，执行速度快；&lt;/p&gt;
&lt;p&gt;缺点：微指令长，编写微程序较麻烦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垂直型微指令&lt;/strong&gt;：类似机器指令操作码的方式，由微操作码字段规定微指令的功能。&lt;/p&gt;
&lt;p&gt;优点：微指令短，简单、规整，便于编写微程序；&lt;/p&gt;
&lt;p&gt;缺点：微程序长，执行速度慢，工作效率低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合型微指令&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-指令流水线&#34;&gt;12. 指令流水线&lt;/h3&gt;
&lt;h3 id=&#34;121-指令流水线的优缺点&#34;&gt;12.1 指令流水线的优缺点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：缩短了程序的执行时间各功能部件的利用率明显提高；&lt;/p&gt;
&lt;p&gt;缺点：需付出较大的硬件开销，控制过程相比顺序执行也更为复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;122-影响流水线的因素&#34;&gt;12.2 影响流水线的因素&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)&lt;strong&gt;资源相关&lt;/strong&gt;：多条指令进入流水线后在同一机器时钟周期使用了同一个功能部件所发生的冲突。&lt;/p&gt;
&lt;p&gt;(2)&lt;strong&gt;数据相关&lt;/strong&gt;：后一条指令必须等待前一条指令执行完毕才能执行。&lt;/p&gt;
&lt;p&gt;(3)&lt;strong&gt;控制相关&lt;/strong&gt;：当执行转移指令时，依据转移条件的产生结果，可能顺序执行下一条指令，也可能转移到新的目标地址取指令，从而使流水线断流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第六章总线&#34;&gt;第六章、总线&lt;/h2&gt;
&lt;h3 id=&#34;61-总线的基本概念&#34;&gt;6.1 总线的基本概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：总线是一组能为多个部件分时共享的公共信息传送线路(物理线路)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：分时+共享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：机械特性(尺寸、形状)+电气特性(传输方向和有效的电平范围)+功能特性(每根传输线的功能)+时间特性(哪根线在什么时候有效)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线的传输周期&lt;/strong&gt;：指CPU通过总线对存储器或I/O端口进行一次访问所需的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线宽度&lt;/strong&gt;：举例，高速公路有16条车道，则宽度就是16。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;62-总线的分类&#34;&gt;6.2 总线的分类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;按照&lt;strong&gt;数据传送方式&lt;/strong&gt;，可分为&lt;code&gt;并行传输总线&lt;/code&gt;和&lt;code&gt;串行传输总线&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;按照&lt;strong&gt;总线的使用范围&lt;/strong&gt;，可分为&lt;code&gt;计算机总线&lt;/code&gt;和&lt;code&gt;测控总线&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;按照&lt;strong&gt;连接部件的不同&lt;/strong&gt;，可分为&lt;code&gt;片内总线&lt;/code&gt;，&lt;code&gt;系统总线&lt;/code&gt;和&lt;code&gt;通信总线&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：片内总线就是芯片内部的总线，系统总线是连接五大不见之间的信息传输线，包括数据总线、地址总线和控制总线。&lt;/p&gt;
&lt;h3 id=&#34;63-总线的组成&#34;&gt;6.3 总线的组成&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一组控制线、一组数据线和一组地址线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;64-总线的性能指标&#34;&gt;6.4 总线的性能指标&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总线宽度&lt;/strong&gt;：通常是指数据总线的根数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线带宽&lt;/strong&gt;：单位时间内总线上传输数据的位数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线复用&lt;/strong&gt;：地址总线和数据总线共用一组线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号线数&lt;/strong&gt;：地址总线、数据总线和控制总线3种总线数的总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;65-总线的结构&#34;&gt;6.5 总线的结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)单总线结构：将CPU、主存和I/O设备都连接在一组总线上，允许它们之间直接交换信息。结构简单，容易扩充外部设备，但不允许两个以上的部件同时向总线传输信息。特点：主存和I/O设备统一编址，CPU可以像访问内存一样访问外部设备。&lt;/p&gt;
&lt;p&gt;(2)双总线结构：将速度较低的I/O 设备从总线中分离出来，形成主存总线与I/O 总线分开的结构。&lt;/p&gt;
&lt;p&gt;(3)三总线结构：在I/O高速设备与主存之间增加了一条DMA总线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;66-总线仲裁确定哪个设备可以使用总线&#34;&gt;6.6 总线仲裁（确定哪个设备可以使用总线）&lt;/h3&gt;
&lt;h3 id=&#34;661-集中仲裁方式&#34;&gt;6.6.1 集中仲裁方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;(1)链式查询方式&lt;/strong&gt;：总线上的所有部件公用一根总线请求线，当由部件请求使用总线时，均需经此线发送请求信息到总线控制器，若总线不忙，则允许请求，否则等待。&lt;/p&gt;
&lt;p&gt;优先级判别方式：离总线控制器越近的部件，其优先级越高。&lt;/p&gt;
&lt;p&gt;优点：结构简答，易扩充；&lt;/p&gt;
&lt;p&gt;缺点：对设备电路的故障敏感，对低优先级的部件不公平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)计数器查询方式&lt;/strong&gt;：采用一个计数器控制总线的使用权。&lt;/p&gt;
&lt;p&gt;优先级判别方式：当总线控制器接收到总线请求信号判断总线不忙时，计数器开始计数，计数值通过一组地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权。同时，终止计数器的计数及查询工作。&lt;/p&gt;
&lt;p&gt;优点：各设备优先级顺序可以改变，而且对电路故障不敏感；&amp;lt;br。
缺点：增加了控制线数，控制较为复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)独立请求方式&lt;/strong&gt;：每一个设备均有一对总线请求信号和总线同意信号。&lt;/p&gt;
&lt;p&gt;优先级判别方式：在总线控制器中排队，等待批准。&lt;/p&gt;
&lt;p&gt;优点：响应时间很快(以增加控制线为代价)，对优先级顺序的控制相当灵活；&lt;/p&gt;
&lt;p&gt;缺点：总线控制更复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;662-分布仲裁方式&#34;&gt;6.6.2 分布仲裁方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要中央仲裁器，每个主模块都有自己的仲裁号和仲裁器，多个仲裁器竞争使用总线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-总线周期&#34;&gt;7. 总线周期&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;完成一次总线操作的时间称为总线周期。&lt;/p&gt;
&lt;p&gt;包括申请分配阶段+寻址阶段+传送数据阶段+结束阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-总线定时&#34;&gt;8. 总线定时&lt;/h3&gt;
&lt;h3 id=&#34;81-同步定时方式&#34;&gt;8.1 同步定时方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;系统采用一个统一的时钟信号来协调发送和接受双方的传送定时关系。时钟信号通常由中央处理器的总线控制器发出，然后送到总线上的所有部件。&lt;/p&gt;
&lt;p&gt;优点：传送给速度快，具有较高的传输速率，总线控制逻辑简单。&lt;/p&gt;
&lt;p&gt;缺点：主从设备之间属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差。&lt;/p&gt;
&lt;p&gt;适用范围：总线长度较短，总线所接部件的存取时间应该比较接近。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;82-异步定时方式&#34;&gt;8.2 异步定时方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;允许各模块的速度不一致，没有公共的时钟标准，不要求所有部件严格地统一操作时间，而是采用应答方式(需要在主从模块之间增加两条应答线）。有不互锁、半互锁和全互锁3种方式。&lt;/p&gt;
&lt;p&gt;优点：总线周期长度可以改变，能保证两个工作速度相差较大的部件或设备之间可靠地进行信息交换，自动适应时间的配合；&lt;/p&gt;
&lt;p&gt;缺点：比同步控制方式稍微复杂一些，速度比同步定时方式慢。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Numpy_intro</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/numpy_intro/" />
            <id>https://tianpingan.github.io/posts/numpy_intro/</id>
            <updated>2021-03-09T16:22:25&#43;08:00</updated>
            <published>2021-03-09T16:06:37&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;h1 id=&#34;numpy光速入门&#34;&gt;numpy光速入门&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;       
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;h3 id=&#34;创建数组&#34;&gt;创建数组&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;np.array()&lt;/code&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-90de7812f9fc3169cffb7e39d4c3cfd8_720w.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;np.ones()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;np.zeros()&lt;/code&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-6e73db4bcf9e406d110da4f2827200ab_720w.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Python_intro</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/python_intro/" />
            <id>https://tianpingan.github.io/posts/python_intro/</id>
            <updated>2021-03-09T15:54:24&#43;08:00</updated>
            <published>2021-03-09T14:55:51&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;h1 id=&#34;python-光速入门&#34;&gt;Python 光速入门&lt;/h1&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	十六进制用&lt;code&gt;0x&lt;/code&gt;前缀标识，如&lt;code&gt;0xff00&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	允许在数字中间以&lt;code&gt;_&lt;/code&gt;分隔&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	科学技术法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	字符串是以单引号&lt;code&gt;&#39;&lt;/code&gt;或双引号&lt;code&gt;&amp;quot;&lt;/code&gt;括起来的任意文本&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;\&lt;/code&gt;是转义字符&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;r&#39;字符串&#39;&lt;/code&gt;，内部的字符串默认不转义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print(&#39;&#39;&#39;line1
line2
line3&#39;&#39;&#39;)
输出：
line1
line2
line3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.布尔值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	只有&lt;code&gt;True&lt;/code&gt;、&lt;code&gt;False&lt;/code&gt;两种值&lt;/p&gt;
&lt;p&gt;​	布尔值可以用&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;运算&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.空值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	None&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;a = &#39;ABC&#39;&lt;/code&gt;，解释器创建了字符串&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;和变量&lt;code&gt;a&lt;/code&gt;，并把&lt;code&gt;a&lt;/code&gt;指向&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cblog%5Cblog%5Ccontent%5Cpic%5C0&#34; alt=&#34;py-var-code-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;b = a&lt;/code&gt;，解释器创建了变量&lt;code&gt;b&lt;/code&gt;，并把&lt;code&gt;b&lt;/code&gt;指向&lt;code&gt;a&lt;/code&gt;指向的字符串&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cblog%5Cblog%5Ccontent%5Cpic%5C0&#34; alt=&#34;py-var-code-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;a = &#39;XYZ&#39;&lt;/code&gt;，解释器创建了字符串&#39;XYZ&#39;，并把&lt;code&gt;a&lt;/code&gt;的指向改为&lt;code&gt;&#39;XYZ&#39;&lt;/code&gt;，但&lt;code&gt;b&lt;/code&gt;并没有更改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;D:%5Cblog%5Cblog%5Ccontent%5Cpic%5C0&#34; alt=&#34;py-var-code-3&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以，最后打印变量&lt;code&gt;b&lt;/code&gt;的结果自然是&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.常量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/&lt;/code&gt;除法计算结果是浮点数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;//&lt;/code&gt;，称为地板除，两个整数的除法仍然是整数&lt;/p&gt;
&lt;h2 id=&#34;字符编码&#34;&gt;字符编码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ASCII：1个字节&lt;/p&gt;
&lt;p&gt;Unicode：通常是2个字节&lt;/p&gt;
&lt;p&gt;UTF-8：把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：&lt;/p&gt;
&lt;p&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/p&gt;
&lt;p&gt;用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.liaoxuefeng.com/files/attachments/923923787018816/0&#34; alt=&#34;rw-file-utf-8&#34;&gt;&lt;/p&gt;
&lt;p&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.liaoxuefeng.com/files/attachments/923923759189600/0&#34; alt=&#34;web-utf-8&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以你看到很多网页的源码上会有类似&lt;code&gt;&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;&lt;/code&gt;的信息，表示该网页正是用的UTF-8编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化输出：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &#39;Hello, %s&#39; % &#39;world&#39;
&#39;Hello, world&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)
&#39;Hi, Michael, you have $1000000.&#39;

print(&#39;%2d-%02d&#39; % (3, 1))
print(&#39;%.2f&#39; % 3.1415926)
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;占位符&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;替换内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;%d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;%f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;%x&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;十六进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果你不太确定应该用什么，&lt;code&gt;%s&lt;/code&gt;永远起作用，它会把任何数据类型转换为字符串&lt;/p&gt;
&lt;h2 id=&#34;list-和-tuple&#34;&gt;list 和 tuple&lt;/h2&gt;
&lt;h3 id=&#34;list&#34;&gt;list&lt;/h3&gt;
&lt;p&gt;Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要取最后第$i$个元素，除了计算索引位置外，还可以用&lt;code&gt;-i&lt;/code&gt;做索引，直接获取最后一个元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classmates[-i]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;追加元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classmates.append(&#39;Adam&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把元素插入到指定的位置，比如索引号为&lt;code&gt;i&lt;/code&gt;的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classmates.insert(1, &#39;Jack&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除list末尾的元素，用&lt;code&gt;pop()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;删除指定位置的元素，用&lt;code&gt;pop(i)&lt;/code&gt;方法，其中&lt;code&gt;i&lt;/code&gt;是索引位置&lt;/p&gt;
&lt;p&gt;list里面的元素的数据类型也可以不同&lt;/p&gt;
&lt;h3 id=&#34;tuple&#34;&gt;tuple&lt;/h3&gt;
&lt;p&gt;tuple和list非常类似，但是tuple一旦初始化就&lt;strong&gt;不能修改&lt;/strong&gt;，比如同样是列出同学的名字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的&lt;/p&gt;
&lt;p&gt;因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。&lt;/p&gt;
&lt;p&gt;只有1个元素的tuple定义时必须加一个逗号&lt;code&gt;,&lt;/code&gt;，来消除歧义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = (1,)
&amp;gt;&amp;gt;&amp;gt; t
(1,)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;条件判断&#34;&gt;条件判断&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;your age is&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;adult&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果&lt;code&gt;if&lt;/code&gt;语句判断是&lt;code&gt;True&lt;/code&gt;，就把缩进的两行print语句执行了，否则，什么也不做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if-else&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;your age is&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;adult&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;your age is&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;teenager&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;if-elif-else&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;teenager&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;adult&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;kid&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;input&#34;&gt;Input&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;input()&lt;/code&gt;读取用户的输入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;birth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;birth: &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是因为&lt;code&gt;input()&lt;/code&gt;返回的数据类型是&lt;code&gt;str&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str&lt;/code&gt;不能直接和整数比较，必须先把&lt;code&gt;str&lt;/code&gt;转换成整数。Python提供了&lt;code&gt;int()&lt;/code&gt;函数来完成这件事情：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;birth: &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;birth&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;循环&#34;&gt;循环&lt;/h2&gt;
&lt;p&gt;Python的循环有两种&lt;/p&gt;
&lt;p&gt;一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Tracy&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;range()&lt;/code&gt;函数，可以生成一个整数序列，再通过&lt;code&gt;list()&lt;/code&gt;函数可以转换为list。比如&lt;code&gt;range(5)&lt;/code&gt;生成的序列是从0开始小于5的整数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(range(5))
[0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二种循环是while循环，只要条件满足，就不断循环&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;break、continue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在循环中，&lt;code&gt;break&lt;/code&gt;语句可以提前退出循环&lt;/p&gt;
&lt;p&gt;在循环过程中，也可以通过&lt;code&gt;continue&lt;/code&gt;语句，跳过当前的这次循环，直接开始下一次循环&lt;/p&gt;
&lt;h2 id=&#34;dict和set&#34;&gt;dict和set&lt;/h2&gt;
&lt;h3 id=&#34;dict&#34;&gt;dict&lt;/h3&gt;
&lt;p&gt;大括号&lt;code&gt;{}&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;95&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;75&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Tracy&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;85&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;95&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Adam&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;67&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;要避免key不存在的错误，有两种办法，一是通过&lt;code&gt;in&lt;/code&gt;判断key是否存在&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Thomas&amp;#39;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;
&lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;二是通过dict提供的&lt;code&gt;get()&lt;/code&gt;方法，如果key不存在，可以返回&lt;code&gt;None&lt;/code&gt;，或者自己指定的value：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Thomas&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Thomas&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;删除key，用&lt;code&gt;pop(key)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;75&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;95&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Tracy&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;85&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;
&lt;p&gt;set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。&lt;/p&gt;
&lt;p&gt;要创建一个set，需要提供一个list作为输入集合&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;传入的参数&lt;code&gt;[1, 2, 3]&lt;/code&gt;是一个list，而显示的&lt;code&gt;{1, 2, 3}&lt;/code&gt;只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;add(key)&lt;/code&gt;方法可以添加元素到set中&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;remove(key)&lt;/code&gt;方法可以删除元素&lt;/p&gt;
&lt;p&gt;set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;在Python中，定义一个函数要使用&lt;code&gt;def&lt;/code&gt;语句，依次写出&lt;strong&gt;函数名&lt;/strong&gt;、&lt;strong&gt;括号&lt;/strong&gt;、括号中的&lt;strong&gt;参数&lt;/strong&gt;和&lt;strong&gt;冒号&lt;/strong&gt;&lt;code&gt;:&lt;/code&gt;，然后，在缩进块中编写&lt;strong&gt;函数体&lt;/strong&gt;，函数的返回值用&lt;code&gt;return&lt;/code&gt;语句返回。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;my_abs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果没有&lt;code&gt;return&lt;/code&gt;语句，函数执行完毕后也会返回结果，只是结果为&lt;code&gt;None&lt;/code&gt;。&lt;code&gt;return None&lt;/code&gt;可以简写为&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你已经把&lt;code&gt;my_abs()&lt;/code&gt;的函数定义保存为&lt;code&gt;abstest.py&lt;/code&gt;文件了，那么，可以在该文件的当前目录下启动Python解释器，用&lt;code&gt;from abstest import my_abs&lt;/code&gt;来导入&lt;code&gt;my_abs()&lt;/code&gt;函数，注意&lt;code&gt;abstest&lt;/code&gt;是文件名（不含&lt;code&gt;.py&lt;/code&gt;扩展名）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想定义一个什么事也不做的空函数，可以用&lt;code&gt;pass&lt;/code&gt;语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;nop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;返回多个值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;math&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;nx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ny&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ny&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;mf&#34;&gt;151.96152422706632&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;70.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但其实这只是一种假象，Python函数返回的仍然是单一值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;151.96152422706632&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;70.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们把函数的参数改为可变参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;calc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numbers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numbers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;sum&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;calc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个&lt;code&gt;*&lt;/code&gt;号。在函数内部，参数&lt;code&gt;numbers&lt;/code&gt;接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：&lt;/p&gt;
&lt;p&gt;Python允许你在list或tuple前面加一个&lt;code&gt;*&lt;/code&gt;号，把list或tuple的元素变成可变参数传进去：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;关键字参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;name:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;age:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;other:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;函数&lt;code&gt;person&lt;/code&gt;除了必选参数&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;外，还接受关键字参数&lt;code&gt;kw&lt;/code&gt;。在调用该函数时，可以只传入必选参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Michael&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;也可以传入任意个数的关键字参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;35&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;city&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bob&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;35&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;city&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Adam&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gender&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;job&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Adam&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;gender&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收&lt;code&gt;city&lt;/code&gt;和&lt;code&gt;job&lt;/code&gt;作为关键字参数。这种方式定义的函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;city&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;job&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;city&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;job&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;和关键字参数&lt;code&gt;**kw&lt;/code&gt;不同，命名关键字参数需要一个特殊分隔符&lt;code&gt;*&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;后面的参数被视为命名关键字参数。&lt;/p&gt;
&lt;p&gt;调用方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;city&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;job&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Jack&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;24&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Beijing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Engineer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;模块&#34;&gt;模块&lt;/h2&gt;
&lt;p&gt;在Python中，一个.py文件就称之为一个模块（Module）。&lt;/p&gt;
&lt;p&gt;如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。&lt;/p&gt;
&lt;p&gt;举个例子，一个&lt;code&gt;abc.py&lt;/code&gt;的文件就是一个名字叫&lt;code&gt;abc&lt;/code&gt;的模块，一个&lt;code&gt;xyz.py&lt;/code&gt;的文件就是一个名字叫&lt;code&gt;xyz&lt;/code&gt;的模块。&lt;/p&gt;
&lt;p&gt;现在，假设我们的&lt;code&gt;abc&lt;/code&gt;和&lt;code&gt;xyz&lt;/code&gt;这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如&lt;code&gt;mycompany&lt;/code&gt;，按照如下目录存放：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ascii&#34; data-lang=&#34;ascii&#34;&gt;mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，&lt;code&gt;abc.py&lt;/code&gt;模块的名字就变成了&lt;code&gt;mycompany.abc&lt;/code&gt;，类似的，&lt;code&gt;xyz.py&lt;/code&gt;的模块名变成了&lt;code&gt;mycompany.xyz&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请注意，每一个包目录下面都会有一个&lt;code&gt;__init__.py&lt;/code&gt;的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。&lt;code&gt;__init__.py&lt;/code&gt;可以是空文件，也可以有Python代码，因为&lt;code&gt;__init__.py&lt;/code&gt;本身就是一个模块，而它的模块名就是&lt;code&gt;mycompany&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ascii&#34; data-lang=&#34;ascii&#34;&gt;mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件&lt;code&gt;www.py&lt;/code&gt;的模块名就是&lt;code&gt;mycompany.web.www&lt;/code&gt;，两个文件&lt;code&gt;utils.py&lt;/code&gt;的模块名分别是&lt;code&gt;mycompany.utils&lt;/code&gt;和&lt;code&gt;mycompany.web.utils&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;使用模块&#34;&gt;使用模块&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#!/usr/bin/env python3&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&#34;s1&#34;&gt;&amp;#39; a test module &amp;#39;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;__author__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Michael Liao&amp;#39;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello, world!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;!&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Too many arguments!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第1行和第2行是标准注释，第1行注释可以让这个&lt;code&gt;hello.py&lt;/code&gt;文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；&lt;/p&gt;
&lt;p&gt;第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；&lt;/p&gt;
&lt;p&gt;第6行使用&lt;code&gt;__author__&lt;/code&gt;变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；&lt;/p&gt;
&lt;p&gt;你可能注意到了，使用&lt;code&gt;sys&lt;/code&gt;模块的第一步，就是导入该模块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;导入&lt;code&gt;sys&lt;/code&gt;模块后，我们就有了变量&lt;code&gt;sys&lt;/code&gt;指向该模块，利用&lt;code&gt;sys&lt;/code&gt;这个变量，就可以访问&lt;code&gt;sys&lt;/code&gt;模块的所有功能。&lt;/p&gt;
&lt;p&gt;当我们在命令行运行&lt;code&gt;hello&lt;/code&gt;模块文件时，Python解释器把一个特殊变量&lt;code&gt;__name__&lt;/code&gt;置为&lt;code&gt;__main__&lt;/code&gt;，而如果在其他地方导入该&lt;code&gt;hello&lt;/code&gt;模块时，&lt;code&gt;if&lt;/code&gt;判断将失败，因此，这种&lt;code&gt;if&lt;/code&gt;测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。&lt;/p&gt;
&lt;h2 id=&#34;安装第三方模块&#34;&gt;安装第三方模块&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装Pillow的命令就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install Pillow
&lt;/code&gt;&lt;/pre&gt;</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Test_for_auto</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/test_for_auto/" />
            <id>https://tianpingan.github.io/posts/test_for_auto/</id>
            <updated>2021-03-08T22:37:12&#43;08:00</updated>
            <published>2021-03-08T22:35:37&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">this is a test</summary>
            
                <content type="html">&lt;p&gt;this is a test&lt;/p&gt;
&lt;p&gt;for&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Test</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/test/" />
            <id>https://tianpingan.github.io/posts/test/</id>
            <updated>2021-03-09T10:51:36&#43;08:00</updated>
            <published>2021-03-08T20:14:55&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;中文测试&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Hello World</title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/hello-world/" />
            <id>https://tianpingan.github.io/posts/hello-world/</id>
            <updated>2021-03-08T21:17:13&#43;08:00</updated>
            <published>2021-03-08T19:51:30&#43;08:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;h1 id=&#34;测试&#34;&gt;测试&lt;/h1&gt;
&lt;p&gt;$$x = x + 1$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/os_meeting/" />
            <id>https://tianpingan.github.io/posts/os_meeting/</id>
            <updated>2021-03-09T17:38:17&#43;08:00</updated>
            <published>0001-01-01T00:00:00&#43;00:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;操作系统是计算机方面的重要难点，在B站听Mooc多次听睡之后，决定以课本与为主，结合网上搜到的高频问题，对常见的操作系统知识做一个归纳整理。&lt;/p&gt;
&lt;p&gt;下文中很多内容是转载，在文章的最后会一一注明。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&#34;1-什么是进程与线程有何区别进程与程序有何区别&#34;&gt;&lt;strong&gt;1 什么是进程与线程，有何区别？进程与程序有何区别？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）线程是进程的一个&lt;strong&gt;实体&lt;/strong&gt;，一个进程可以拥有&lt;strong&gt;多个线程&lt;/strong&gt;，多个线程也可以&lt;strong&gt;并发执行&lt;/strong&gt;。一个没有线程的进程也可以看做是单线程的，同样线程也经常被看做是一种轻量级的进程。并且进程可以不依赖于线程而单独存在，而线程则不然。&lt;/p&gt;
&lt;p&gt;（2）进程是并发程序在一个数据集合上的一次&lt;strong&gt;执行过程&lt;/strong&gt;，进程是系统进行&lt;strong&gt;资源分配和调度&lt;/strong&gt;的独立单位，线程是进程的实体，它是比进程更小的能够独立执行的基本单元，线程自己不拥有任何&lt;strong&gt;系统资源&lt;/strong&gt;，但是它可以访问其隶属进程的全部资源。&lt;/p&gt;
&lt;p&gt;（3） 与进程的控制表&lt;strong&gt;PCB&lt;/strong&gt;相似，线程也有自己的控制表&lt;strong&gt;TCB&lt;/strong&gt;，但是TCB中所保存的线程状态比PCB表少得多。&lt;/p&gt;
&lt;p&gt;进程的作用与定义：是为了提高CPU的执行效率，为了避免因等待而造成CPU空转以及其他计算机硬件资源的浪费而提出来的。&lt;/p&gt;
&lt;p&gt;线程的引入：例如，有一个Web服务器要进程的方式并发地处理来自不同用户的网页访问请求的话，可以创建父进程和多个子进程的方式来进行处理，但是创建一个进程要花费较大的&lt;strong&gt;系统开销&lt;/strong&gt;和占用较多的&lt;strong&gt;资源&lt;/strong&gt;。除外，这些不同的用户子进程在执行的时候涉及到&lt;strong&gt;进程上下文切换&lt;/strong&gt;，上下文切换是一个复杂的过程。所以，为了减少进程切换和创建的开销，提高执行效率和节省资源，人们在操作系统中引入了&amp;quot;线程（thread）&amp;quot;的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是具有&lt;strong&gt;一定独立功能的程序关于某个数据集合上的一次运行活动&lt;/strong&gt;，进程是系统&lt;strong&gt;进行资源分配和调度的一个独立单位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;线程是进程的一个实体，是&lt;strong&gt;CPU调度和分派的基本单位&lt;/strong&gt;，它是比进程更小的能独立运行的基本单位。&lt;/p&gt;
&lt;p&gt;线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程**共享进程所拥有的全部资源。&lt;strong&gt;一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以&lt;/strong&gt;并发执行。**由于线程基本不拥有系统资源，所以在进行切换时，线程切换的开销远远小于进程。&lt;/p&gt;
&lt;p&gt;　进程与应用程序的区别在于应用程序作为一个&lt;strong&gt;静态文件&lt;/strong&gt;存储在计算机系统的硬盘等存储空间中，而进程则是处于&lt;strong&gt;动态条件&lt;/strong&gt;下由操作系统维护的&lt;strong&gt;系统资源管理实体。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;使用系统运行资源情况&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;程序&lt;/td&gt;
&lt;td&gt;计算机指令的集合，它以文件的形式存储在磁盘上。程序是&lt;strong&gt;静态实体&lt;/strong&gt;（passive Entity），在多道程序系统中，它是不能独立运行的，更不能与其他程序并发执行。&lt;/td&gt;
&lt;td&gt;不使用【程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占用系统的运行资源】。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;进程&lt;/td&gt;
&lt;td&gt;通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。定义：进程是&lt;strong&gt;进程实体&lt;/strong&gt;（包括：程序段、相关的数据段、进程控制块PCB）的运行过程，是系统进行资源分配和调度的一个独立单位。&lt;/td&gt;
&lt;td&gt;使用【进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源。】&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果说操作系统引入进程的目的是为了提高程序并发执行，以提高资源利用率和系统吞吐量。那么操作系统中引入线程的目的，则是为了减少进程并发执行过程中所付出的时空开销，使操作系统能很好的并发执行。&lt;/p&gt;
&lt;p&gt;　　进程process定义了一个&lt;strong&gt;执行环境&lt;/strong&gt;，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个&lt;strong&gt;控制流&lt;/strong&gt;，有他自己的调用栈call stack，记录了它的执行历史。&lt;/p&gt;
&lt;p&gt;　　线程由两个部分组成：1）&lt;strong&gt;线程的内核对象&lt;/strong&gt;，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。2）&lt;strong&gt;线程堆栈&lt;/strong&gt;，它用于维护线程在执行代码时需要的所有参数和局部变量。当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。&lt;/p&gt;
&lt;p&gt;　　进程与线程的比较如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较&lt;/th&gt;
&lt;th&gt;进程&lt;/th&gt;
&lt;th&gt;线程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;活泼性&lt;/td&gt;
&lt;td&gt;不活泼（只是线程的容器）&lt;/td&gt;
&lt;td&gt;活泼&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;地址空间&lt;/td&gt;
&lt;td&gt;系统赋予的独立的&lt;strong&gt;虚拟地址空间&lt;/strong&gt;（对于32位进程来说，这个地址空间是4GB）&lt;/td&gt;
&lt;td&gt;在进程的地址空间执行代码。线程只有一个内核对象和一个堆栈，保留的记录很少，因此所需要的内存也很少。因为线程需要的&lt;strong&gt;开销比进程少&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调度&lt;/td&gt;
&lt;td&gt;仅是&lt;strong&gt;资源分配&lt;/strong&gt;的基本单位&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;独立调度、分派&lt;/strong&gt;的基本单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并发性&lt;/td&gt;
&lt;td&gt;仅进程间并发（传统OS）&lt;/td&gt;
&lt;td&gt;进程间、线程间并发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;拥有资源&lt;/td&gt;
&lt;td&gt;资源拥有的基本单位&lt;/td&gt;
&lt;td&gt;基本上不拥有资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统开销&lt;/td&gt;
&lt;td&gt;创建、撤销、切换开销大&lt;/td&gt;
&lt;td&gt;仅保存少量寄存器内容，开销小。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-线程同步的方式有哪些&#34;&gt;2 &lt;strong&gt;线程同步&lt;/strong&gt;的方式有哪些？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥量&lt;/strong&gt;：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件（信号）&lt;/strong&gt;：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-windows下的内存是如何管理的&#34;&gt;3 &lt;strong&gt;windows&lt;/strong&gt;下的内存是如何管理的？&lt;/h2&gt;
&lt;p&gt;Windows提供了3种方法来进行内存管理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt;，最适合用来管理&lt;strong&gt;大型对象或者结构数组&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存映射文件&lt;/strong&gt;，最适合用来管理&lt;strong&gt;大型数据流&lt;/strong&gt;（通常来自文件）以及在单个计算机上运行&lt;strong&gt;多个进程之间共享数据&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存堆栈&lt;/strong&gt;，最适合用来管理&lt;strong&gt;大量的小对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;4-中断和轮询的特点&#34;&gt;4 &lt;strong&gt;中断和轮询&lt;/strong&gt;的特点&lt;/h2&gt;
&lt;p&gt;对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序&lt;strong&gt;轮询&lt;/strong&gt;是一种&lt;strong&gt;效率较低&lt;/strong&gt;的方式，在现代计算机系统中已很少应用。&lt;/p&gt;
&lt;p&gt;　　程序中断通常简称&lt;strong&gt;中断&lt;/strong&gt;，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。&lt;/p&gt;
&lt;p&gt;　　轮询——效率低，等待时间很长，CPU利用率不高。&lt;/p&gt;
&lt;p&gt;　　中断——容易遗漏一些问题，CPU利用率高。&lt;/p&gt;
&lt;h2 id=&#34;5-什么是临界区如何解决冲突&#34;&gt;5 什么是&lt;strong&gt;临界区&lt;/strong&gt;？如何解决冲突？&lt;/h2&gt;
&lt;p&gt;每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。&lt;/p&gt;
&lt;p&gt;　　（1）如果有若干进程要求进入空闲的临界区，&lt;strong&gt;一次仅允许一个进程进入&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;　　（2）任何时候，&lt;strong&gt;处于临界区内的进程不可多于一个&lt;/strong&gt;。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；&lt;/p&gt;
&lt;p&gt;　　（3）进入临界区的进程要在&lt;strong&gt;有限时间内退出&lt;/strong&gt;，以便其它进程能及时进入自己的临界区；&lt;/p&gt;
&lt;p&gt;　　（4）如果进程不能进入自己的临界区，则应&lt;strong&gt;让出CPU&lt;/strong&gt;，避免进程出现“忙等”现象。&lt;/p&gt;
&lt;h2 id=&#34;6-说说分段和分页&#34;&gt;6 说说&lt;strong&gt;分段和分页&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个&lt;strong&gt;二维地址空间&lt;/strong&gt;，相互独立，互不干扰。段式管理的优点是：&lt;strong&gt;没有内碎片&lt;/strong&gt;（因为段大小可变，改变段大小来消除内碎片）。但&lt;strong&gt;段换入换出时，会产生外碎片&lt;/strong&gt;（比如4k的段换5k的段，会产生1k的外碎片）&lt;/p&gt;
&lt;p&gt;页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的&lt;strong&gt;逻辑地址划分为固定大小的页（page）&lt;/strong&gt;，而&lt;strong&gt;物理内存&lt;/strong&gt;划分为同样大小的&lt;strong&gt;帧&lt;/strong&gt;，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：&lt;strong&gt;没有外碎片&lt;/strong&gt;（因为页的大小固定），但&lt;strong&gt;会产生内碎片&lt;/strong&gt;（一个页可能填充不满）。&lt;/p&gt;
&lt;p&gt;两者的不同点：&lt;/p&gt;
&lt;p&gt;目的不同：分页是由于系统管理的需要而不是用户的需要，它是&lt;strong&gt;信息的物理单位&lt;/strong&gt;；分段的目的是为了能更好地满足用户的需要，它是&lt;strong&gt;信息的逻辑单位&lt;/strong&gt;，它含有一组其&lt;strong&gt;意义相对完整&lt;/strong&gt;的信息；&lt;/p&gt;
&lt;p&gt;大小不同：页的&lt;strong&gt;大小固定&lt;/strong&gt;且由系统决定，而段的长度却&lt;strong&gt;不固定&lt;/strong&gt;，由其所完成的功能决定；&lt;/p&gt;
&lt;p&gt;地址空间不同： 段向用户提供&lt;strong&gt;二维地址空间&lt;/strong&gt;；页向用户提供的是&lt;strong&gt;一维地址空间&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；&lt;/p&gt;
&lt;p&gt;内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;段是信息的&lt;strong&gt;逻辑单位&lt;/strong&gt;，它是根据&lt;strong&gt;用户的需要&lt;/strong&gt;划分的，因此段对用户是可见的 ；页是信息的&lt;strong&gt;物理单位&lt;/strong&gt;，是为了&lt;strong&gt;管理主存&lt;/strong&gt;的方便而划分的，对用户是透明的。&lt;/li&gt;
&lt;li&gt;段的大小&lt;strong&gt;不固定&lt;/strong&gt;，有它所完成的功能决定；页大大小&lt;strong&gt;固定&lt;/strong&gt;，由系统决定&lt;/li&gt;
&lt;li&gt;段向用户提供&lt;strong&gt;二维地址空间&lt;/strong&gt;；页向用户提供的是&lt;strong&gt;一维地址空间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;段是信息的逻辑单位，便于&lt;strong&gt;存储保护和信息的共享&lt;/strong&gt;，页的保护和共享&lt;strong&gt;受到限制&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​    页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。&lt;/p&gt;
&lt;p&gt;　　段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。&lt;/p&gt;
&lt;p&gt;　　页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。&lt;/p&gt;
&lt;p&gt;　　分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。&lt;/p&gt;
&lt;h2 id=&#34;7-保持进程同步的方法&#34;&gt;7 保持&lt;strong&gt;进程同步&lt;/strong&gt;的方法？&lt;/h2&gt;
&lt;p&gt;进程间同步的主要方法有&lt;strong&gt;原子操作、信号量机制、自旋锁、管程、会合、分布式系统&lt;/strong&gt;等。&lt;/p&gt;
&lt;h2 id=&#34;8-linux中常用到的命令&#34;&gt;8 &lt;strong&gt;Linux&lt;/strong&gt;中常用到的命令&lt;/h2&gt;
&lt;p&gt;​    显示文件目录命令ls    如ls&lt;/p&gt;
&lt;p&gt;　　改变当前目录命令cd    如cd /home&lt;/p&gt;
&lt;p&gt;　　建立子目录mkdir      如mkdir xiong&lt;/p&gt;
&lt;p&gt;　　删除子目录命令rmdir    如rmdir /mnt/cdrom&lt;/p&gt;
&lt;p&gt;　　删除文件命令rm      如rm /ucdos.bat&lt;/p&gt;
&lt;p&gt;　　文件复制命令cp      如cp /ucdos /fox&lt;/p&gt;
&lt;p&gt;　　获取帮助信息命令man   如man ls&lt;/p&gt;
&lt;p&gt;　　显示文件的内容less    如less mwm.lx&lt;/p&gt;
&lt;p&gt;　　重定向与管道type     如type readme&amp;gt;&amp;gt;direct，将文件readme的内容追加到文direct中&lt;/p&gt;
&lt;h2 id=&#34;9-makefile文件的作用是什么&#34;&gt;9 &lt;strong&gt;makefile文件&lt;/strong&gt;的作用是什么？&lt;/h2&gt;
&lt;p&gt;工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中。makefile&lt;strong&gt;定义了一系列的规则&lt;/strong&gt;来指定哪些文件需要先编译，哪些文件需要后&lt;strong&gt;编译&lt;/strong&gt;，哪些文件需要重新编译，甚至于进行更复杂的功能操作。&lt;/p&gt;
&lt;h2 id=&#34;10-什么是中断中断时cpu做什么工作&#34;&gt;10 什么是&lt;strong&gt;中断&lt;/strong&gt;？中断时CPU做什么工作？&lt;/h2&gt;
&lt;p&gt;中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU&lt;strong&gt;暂时中断&lt;/strong&gt;当前正在执行的程序而转去执行相应的事件处理程序。待&lt;strong&gt;处理完毕后又返回&lt;/strong&gt;原来被中断处继续执行或调度新的进程执行的过程。&lt;/p&gt;
&lt;h2 id=&#34;11-你知道操作系统的内容分为几块吗什么叫做虚拟内存他和主存的关系如何内存管理属于操作系统的内容吗&#34;&gt;11 你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？&lt;/h2&gt;
&lt;p&gt;操作系统的主要组成部分：&lt;strong&gt;进程和线程的管理，存储管理，设备管理，文件管理&lt;/strong&gt;。虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上&lt;strong&gt;虚拟内存就是用于物理内存的临时存放的磁盘空间&lt;/strong&gt;。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。&lt;/p&gt;
&lt;h2 id=&#34;12-什么是缓冲区溢出有什么危害其原因是什么&#34;&gt;12 什么是&lt;strong&gt;缓冲区溢出&lt;/strong&gt;？有什么危害？其原因是什么？&lt;/h2&gt;
&lt;p&gt;缓冲区溢出是指当计算机向缓冲区内填充数据时&lt;strong&gt;超过了缓冲区本身的容量&lt;/strong&gt;，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主原因是程序中&lt;strong&gt;没有仔细检查用户输入的参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;危害有以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序崩溃&lt;/strong&gt;，导致拒绝额服务&lt;/li&gt;
&lt;li&gt;跳转并且&lt;strong&gt;执行一段恶意代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-什么是死锁其条件是什么怎样避免死锁&#34;&gt;13 什么是&lt;strong&gt;死锁&lt;/strong&gt;？其条件是什么？怎样避免死锁？&lt;/h2&gt;
&lt;p&gt;死锁的概念：&lt;strong&gt;在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。&lt;strong&gt;通俗地讲，就是两个或多个进程被&lt;/strong&gt;无限期地阻塞、相互等待&lt;/strong&gt;的一种状态。&lt;/p&gt;
&lt;p&gt;　　死锁产生的原因主要是： 系统资源不足； 进程推进顺序非法。&lt;/p&gt;
&lt;p&gt;　　产生死锁的必要条件：&lt;/p&gt;
&lt;p&gt;　　（1）&lt;strong&gt;互斥&lt;/strong&gt;（mutualexclusion），一个资源每次只能被一个进程使用；&lt;/p&gt;
&lt;p&gt;　　（2）&lt;strong&gt;不可抢占&lt;/strong&gt;（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；&lt;/p&gt;
&lt;p&gt;　　（3）**占有并等待（**hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；&lt;/p&gt;
&lt;p&gt;　　（4）&lt;strong&gt;环形等待&lt;/strong&gt;（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。&lt;/p&gt;
&lt;p&gt;　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。&lt;/p&gt;
&lt;p&gt;　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。&lt;/p&gt;
&lt;p&gt;　　死锁的处理策略：&lt;strong&gt;鸵鸟策略、预防策略、避免策略、检测与恢复策略&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;14-进程间的通信是如何实现的&#34;&gt;14 &lt;strong&gt;进程间的通信&lt;/strong&gt;是如何实现的？&lt;/h2&gt;
&lt;p&gt;进程间通讯的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管道&lt;/strong&gt;中还有命名管道和非命名管道之分，&lt;strong&gt;非命名管道&lt;/strong&gt;只能用于&lt;strong&gt;父子进程通讯&lt;/strong&gt;，&lt;strong&gt;命名管道&lt;/strong&gt;可用于&lt;strong&gt;非父子进程&lt;/strong&gt;，命名管道就是FIFO，管道是&lt;strong&gt;先进先出&lt;/strong&gt;的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用&lt;strong&gt;创建文件的方式建立的&lt;/strong&gt;，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;， 不能传递复杂消息，只能&lt;strong&gt;用来同步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享内存&lt;/strong&gt;，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种方式的比较：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管道&lt;/strong&gt;：&lt;strong&gt;速度慢，容量有限&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;：不能传递复杂消息，只能用来同步&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享内存区&lt;/strong&gt;：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。&lt;/p&gt;
&lt;p&gt;所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。&lt;/p&gt;
&lt;p&gt;高级通信机制可归结为三大类：&lt;/p&gt;
&lt;p&gt;　　（1）&lt;strong&gt;共享存储器系统&lt;/strong&gt;（存储器中划分的共享存储区）；实际操作中对应的是**“剪贴板”**（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。&lt;/p&gt;
&lt;p&gt;　　（2）&lt;strong&gt;消息传递系统&lt;/strong&gt;（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：&lt;strong&gt;邮槽&lt;/strong&gt;（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。&lt;/p&gt;
&lt;p&gt;　　（3）&lt;strong&gt;管道通信系统&lt;/strong&gt;（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。&lt;strong&gt;匿名管道&lt;/strong&gt;只能实现&lt;strong&gt;本地&lt;/strong&gt;机器上两个进程之间的通信，而不能实现跨网络的通信。&lt;strong&gt;命名管道&lt;/strong&gt;不仅可以在本机上实现两个进程间的通信，还可以&lt;strong&gt;跨网络&lt;/strong&gt;实现两个进程间的通信。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;同一机器两个进程间通信&lt;/th&gt;
&lt;th&gt;跨网络通信&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;剪贴板Clipboard&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;匿名管道Pipe&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命名管道（点对点单一通信，数据量可较大）Namedpipe&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;邮槽（一对多，数据量较小，424字节以下）Mailslot&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;15-进程有哪几种状态&#34;&gt;15 &lt;strong&gt;进程&lt;/strong&gt;有哪几种状态？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源&lt;/li&gt;
&lt;li&gt;运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数&lt;/li&gt;
&lt;li&gt;阻塞状态： 进程等待某种条件，在条件满足之前无法执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;16-操作系统中进程调度策略有哪几种&#34;&gt;16 操作系统中&lt;strong&gt;进程调度策略&lt;/strong&gt;有哪几种？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FCFS&lt;/strong&gt;(先来先服务)，&lt;strong&gt;优先级&lt;/strong&gt;，&lt;strong&gt;时间片&lt;/strong&gt;轮转，&lt;strong&gt;多级反馈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FCFS&lt;/strong&gt;(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SJF(最短作业优先调度算法)&lt;/strong&gt;：平均等待时间最短，但难以知道下一个CPU区间长度&lt;/p&gt;
&lt;p&gt;**优先级调度算法(**可以是抢占的，也可以是非抢占的)：&lt;strong&gt;优先级越高越先分配到CPU&lt;/strong&gt;，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间片轮转调度算法&lt;/strong&gt;(可抢占的)：队列中**没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。**如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级队列调度算法&lt;/strong&gt;：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级反馈队列调度算法&lt;/strong&gt;：与多级队列调度算法相比，其&lt;strong&gt;允许进程在队列之间移动&lt;/strong&gt;：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。&lt;/p&gt;
&lt;h2 id=&#34;17-threadlocal与其它同步机制的比较&#34;&gt;17 &lt;strong&gt;ThreadLocal&lt;/strong&gt;与其它同步机制的比较&lt;/h2&gt;
&lt;p&gt;Threadlocal和其他所有的同步机制都是为了解决多线程中的对同一变量的访问冲突，在普通的同步机制中，是通过对对象加锁来实现多个线程对同一变量的安全访问的。这时该变量是多个线程共享的，使用这种同步机制需要很细致的分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的索等等。所有这些都是因为多个线程共享了该资源造成的。Threadlocal就从另一个角度来解决多线程的并发访问，Threadlocal会&lt;strong&gt;为每一个线程维护一个和该线程绑定的变量副本，从而隔离了多个线程的数据共享&lt;/strong&gt;，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。&lt;/p&gt;
&lt;p&gt;总结：当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。&lt;strong&gt;同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源&lt;/strong&gt;（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行&lt;strong&gt;多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal&lt;/strong&gt;，这将极大地简化你的程序，使程序更加易读、简洁。&lt;/p&gt;
&lt;h2 id=&#34;18-局部性原理&#34;&gt;18 &lt;strong&gt;局部性原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;(1). &lt;strong&gt;时间&lt;/strong&gt;上的局部性：&lt;strong&gt;最近被访问的页&lt;/strong&gt;在不久的将来还会被访问；&lt;/p&gt;
&lt;p&gt;(2). &lt;strong&gt;空间上的局部性&lt;/strong&gt;：内存中被访问的页&lt;strong&gt;周围的页&lt;/strong&gt;也很可能被访问。&lt;/p&gt;
&lt;h2 id=&#34;19-内存颠簸&#34;&gt;19 &lt;strong&gt;内存颠簸&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;颠簸本质上是指&lt;strong&gt;频繁的页调度&lt;/strong&gt;行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻&lt;strong&gt;再次需要这个页&lt;/strong&gt;。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。&lt;/p&gt;
&lt;p&gt;内存颠簸的解决策略包括：&lt;/p&gt;
&lt;p&gt;如果是因为页面替换策略失误，可以&lt;strong&gt;修改替换算法&lt;/strong&gt;来解决这个问题；&lt;/p&gt;
&lt;p&gt;如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要&lt;strong&gt;降低多道程序的数量&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;否则，还剩下两个办法：&lt;strong&gt;终止该进程或增加物理内存容量&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;20-虚拟内存的应用与优点&#34;&gt;20 &lt;strong&gt;虚拟内存&lt;/strong&gt;的应用与优点&lt;/h2&gt;
&lt;p&gt;虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页&lt;strong&gt;被映射到物理内存&lt;/strong&gt;，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。 注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。　　　　　　　　　　　　　　　　　　&lt;/p&gt;
&lt;p&gt;　　由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459292_F5CB0AD2C92C30DF24FC9C18034B313D&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在内存中可以保留多个进程，系统并发度提高&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21-页面置换算法&#34;&gt;21 &lt;strong&gt;页面置换&lt;/strong&gt;算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FIFO先进先出算法&lt;/strong&gt;：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；&lt;/p&gt;
&lt;p&gt;LRU（Least recently use）&lt;strong&gt;最近最少使用算法&lt;/strong&gt;：根据使用时间到现在的长短来判断；&lt;/p&gt;
&lt;p&gt;LFU（Least frequently use**）最少使用次数算法**：根据使用次数来判断；&lt;/p&gt;
&lt;p&gt;OPT（Optimal replacement）&lt;strong&gt;最优置换算法&lt;/strong&gt;：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。&lt;/p&gt;
&lt;h2 id=&#34;22-线程有几种状态进程呢&#34;&gt;22 &lt;strong&gt;线程&lt;/strong&gt;有几种状态，&lt;strong&gt;进程&lt;/strong&gt;呢？&lt;/h2&gt;
&lt;p&gt;在 Java虚拟机 中，&lt;strong&gt;线程&lt;/strong&gt;从最初的创建到最终的消亡，要经历若干个状态：**创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。**在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：
&lt;strong&gt;进程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;：进程已获得除处理机以外的所需资源，等待分配处理机资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行状态&lt;/strong&gt;：占用处理机资源运行，处于此状态的进程数小于等于CPU数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞状态&lt;/strong&gt;： 进程等待某种条件，在条件满足之前无法执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459692_F5CB0AD2C92C30DF24FC9C18034B313D&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-孤儿进程僵尸进程守护进程&#34;&gt;23 &lt;strong&gt;孤儿进程，僵尸进程，守护进程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;孤儿进程&lt;/strong&gt;：如果&lt;strong&gt;父进程先退出,子进程还没退出&lt;/strong&gt;那么子进程将被托孤给init进程,这是子进程的父进程就是init进程(1号进程).其实还是很好理解的&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;僵尸进程&lt;/strong&gt;：如果我们了解过linux进程状态及转换关系,我们应该知道进程这么多状态中有一种状态是僵死状态,就是进程终止后进入僵死状态(zombie),等待告知父进程自己终止,后才能完全消失.但是如果&lt;strong&gt;一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程&lt;/strong&gt;.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;守护进程&lt;/strong&gt;：同样我们需要了解一下什么是守护进程,&lt;strong&gt;守护进程就是在后台运行,不与任何终端关联的进程&lt;/strong&gt;,通常情况下守护进程在系统启动时就在运行,它们以root用户或者其他特殊用户(apache和postfix)运行,并能处理一些系统级的任务.习惯上守护进程的名字通常以d结尾(sshd),但这些不是必须的.&lt;/p&gt;
&lt;h2 id=&#34;24-线程池问题&#34;&gt;24 &lt;strong&gt;线程池&lt;/strong&gt;问题&lt;/h2&gt;
&lt;p&gt;多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力，但是如果不加控制，反而会对系统造成负担。线程本身也要占用内存空间，大量的线程会占用内存资源并且可能会导致Out of Memory。即便没有这样的情况，大量的线程回收也会给GC带来很大的压力。&lt;/p&gt;
&lt;p&gt;为了避免重复的创建线程，&lt;strong&gt;线程池的出现可以让线程进行复用&lt;/strong&gt;。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是&lt;strong&gt;将这个线程归还给线程池&lt;/strong&gt;供其他任务使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;操作系统常见面试题总结 &lt;a href=&#34;https://blog.csdn.net/youngchang06hpu/article/details/8009947#commentBox&#34;&gt;https://blog.csdn.net/youngchang06hpu/article/details/8009947#commentBox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/memewry/archive/2012/08/25/2656966.html&#34;&gt;操作系统面试题&lt;/a&gt; &lt;a href=&#34;https://www.cnblogs.com/memewry/archive/2012/08/25/2656966.html&#34;&gt;https://www.cnblogs.com/memewry/archive/2012/08/25/2656966.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;常见面试题整理--操作系统篇（每位开发者必备）&lt;a href=&#34;https://zhuanlan.zhihu.com/p/23755202&#34;&gt;ht&lt;/a&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/23755202&#34;&gt;tps://zhuanlan.zhihu.com/p/23755202&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面试/笔试第二弹 —— 操作系统面试问题集锦 &lt;a href=&#34;https://blog.csdn.net/justloveyou_/article/details/78304294&#34;&gt;https://blog.csdn.net/justloveyou_/article/details/78304294&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;孤儿进程，僵尸进程，守护进程：https://www.cnblogs.com/wannable/p/6021617.html&lt;/p&gt;
&lt;p&gt;理解java线程池：https://www.cnblogs.com/superfj/p/7544971.html&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;附：常见知识点：https://blog.csdn.net/qq_39207948/article/details/80677811&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;进程&lt;/strong&gt;是并发过程中程序的&lt;strong&gt;执行过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、进程的特征：结构特征 动态性 并发性 独立性 异步性&lt;/p&gt;
&lt;p&gt;3、临界区指在每个进程中&lt;strong&gt;访问临界资源的那段代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4，现在操作系统中&lt;strong&gt;申请资源的基本单位是进程&lt;/strong&gt;，在CPU得到&lt;strong&gt;执行的基本单位是线程&lt;/strong&gt;，进程是由&lt;strong&gt;程序段、数据段、PCB&lt;/strong&gt;组成的&lt;/p&gt;
&lt;p&gt;5，对&lt;strong&gt;临界资源&lt;/strong&gt;应采取&lt;strong&gt;互斥访问&lt;/strong&gt;方式来实现共享&lt;/p&gt;
&lt;p&gt;6，&lt;strong&gt;P.V操作&lt;/strong&gt;是一种&lt;strong&gt;低级进程通信原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7，对于记录性信号量，在执行一次&lt;strong&gt;P操作&lt;/strong&gt;时，信号量的值应当&lt;strong&gt;减1&lt;/strong&gt;，当其值为小于0时进程应阻塞；在执行&lt;strong&gt;V操作&lt;/strong&gt;时，信号量的值应当&lt;strong&gt;加1&lt;/strong&gt;；当其值小于等于0时，应唤醒阻塞队列中的进程。&lt;/p&gt;
&lt;p&gt;8，N个进程共享某一临界资源，（n-1）~1&lt;/p&gt;
&lt;p&gt;9，&lt;strong&gt;短作业优先算法&lt;/strong&gt;，T1&amp;lt;T2&amp;lt;T3平均周转时间为：T1+2XT2/3+T3/3&lt;/p&gt;
&lt;p&gt;10，&lt;strong&gt;响应比Rp&lt;/strong&gt;=（等待时间+要求服务时间）/要求服务器时间=响应时间/要求服务时间&lt;/p&gt;
&lt;p&gt;11，&lt;strong&gt;死锁&lt;/strong&gt;是指多个进程在运行过程中因争夺资源，而造成的一种僵局，当进程处于这种僵局状态时，若无外力作用，他们都将无法再向前推进。&lt;/p&gt;
&lt;p&gt;死锁的避免是根据防止系统进入不安全状态。&lt;/p&gt;
&lt;p&gt;产生死锁的根本原因是资源分配不当和资源数量不足，发生死锁的四个必要条件是：&lt;strong&gt;互斥条件，请求和保持条件，不剥夺条件和环路等待条件&lt;/strong&gt;，&lt;strong&gt;银行家算法&lt;/strong&gt;用于避免死锁&lt;/p&gt;
&lt;p&gt;12，如果系统中有N个进程，最多为（N-1）个&lt;/p&gt;
&lt;p&gt;13，若系统采用&lt;strong&gt;轮转法调度进程&lt;/strong&gt;系统采用的是&lt;strong&gt;剥夺式调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14，既考虑作业等待时间，又考虑作业执行时间的调度算法是&lt;strong&gt;响应比优先调度算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;15，&lt;strong&gt;资源的有序分配策略&lt;/strong&gt;可以破坏死锁的“循环等待”&lt;/p&gt;
&lt;p&gt;16，并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后变有可能进入死锁状态，&lt;/p&gt;
&lt;p&gt;17，&lt;strong&gt;重定位&lt;/strong&gt;：在&lt;strong&gt;作业地址空间&lt;/strong&gt;中使用的&lt;strong&gt;逻辑地址变为内存物理地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;18，支持程序放在不连续内存中储存管理方法有分取式分配，分段式分配，段页式分配页式存储主要特点是不要将作业同时全部装入到主存的的连续区域&lt;/p&gt;
&lt;p&gt;19，适合多道程序运行的存储管理中，&lt;strong&gt;存储保护&lt;/strong&gt;是为了防止各道作业的相互干扰&lt;/p&gt;
&lt;p&gt;20，采用&lt;strong&gt;页式存储管理&lt;/strong&gt;时，重定位的工作由&lt;strong&gt;地址转换机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;21，段页式存储管理中的地址映像表是每个作业或进程一张段表，每个段一张页表&lt;/p&gt;
&lt;p&gt;22，在虚拟页式存储管理方案中，完成将&lt;strong&gt;页面调入内存&lt;/strong&gt;的工作的是&lt;strong&gt;缺页中断处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;23，分段管理和分页管理的主要区别是&lt;strong&gt;分页管理有存储保护&lt;/strong&gt;，分段管理没有&lt;/p&gt;
&lt;p&gt;24，在股低估分区分配中，可以不同但预先固定的&lt;/p&gt;
&lt;p&gt;25，&lt;strong&gt;不使用中断机构&lt;/strong&gt;的I/O控制方式是&lt;strong&gt;程序I/O方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;26，&lt;strong&gt;spooling技术&lt;/strong&gt;能&lt;strong&gt;独占设备改造成可以共享的虚拟设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;27，磁盘防伪中把数据从磁盘读出，叫做传输时间&lt;/p&gt;
&lt;p&gt;28，&lt;strong&gt;共享设备&lt;/strong&gt;指&lt;strong&gt;同一时间内运行多个进程同时访问&lt;/strong&gt;的设备&lt;/p&gt;
&lt;p&gt;29，通过软件的功能扩充，把原来独占的设备爱造成若干个可共享的设备，虚拟设备&lt;/p&gt;
&lt;p&gt;30，&lt;strong&gt;DMA方式&lt;/strong&gt;如果I/O设备不通过CPU来完成&lt;/p&gt;
&lt;p&gt;31，设备独立性用户程序独立于具体物理设备的一种特性&lt;/p&gt;
&lt;p&gt;32，虚拟设备一个物理设备变换成多个对应的逻辑设备&lt;/p&gt;
&lt;p&gt;33，&lt;strong&gt;通道&lt;/strong&gt;是一种&lt;strong&gt;特殊的处理机&lt;/strong&gt;，通道按传递数据的方式分为：字节多路通道，数组选择通道，数组多路通道&lt;/p&gt;
&lt;p&gt;通道涉及的数据结构是设备控制器，控制器控制块，通道控制块，系统设备表&lt;/p&gt;
&lt;p&gt;34，&lt;strong&gt;磁盘高速缓冲&lt;/strong&gt;设在内存中，目的是提高I/O磁盘速度&lt;/p&gt;
&lt;p&gt;35，磁盘空间的地址有盘面号，柱面号，扇区号组成。访问磁盘的时间有 寻道时间，旋转等待时间，读写时间&lt;/p&gt;
&lt;p&gt;36，将系统段用参数翻译成设备操作命令的工作由设备无关的操作系统完成&lt;/p&gt;
&lt;p&gt;37，向设备寄存器写入控制命令由&lt;strong&gt;设备驱动程序&lt;/strong&gt;完成&lt;/p&gt;
&lt;p&gt;38，寻找设备驱动程序由设备无关的操作系统软件完成&lt;/p&gt;
&lt;p&gt;39，设备管理的功能是设备分配，缓冲区管理和实现物理I/O设备的操作&lt;/p&gt;
&lt;p&gt;40，根据设备的固有属性特点，设备可分为&lt;strong&gt;独占设备，共享设备和虚拟设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;41，引入&lt;strong&gt;缓冲区技术&lt;/strong&gt;可提高处理器执行程序和设备的输入输出操作的并行程序文件管理&lt;/p&gt;
&lt;p&gt;42，物理文件的组织方式是由操作系统确定的，文件的顺序存取是按文件的逻辑号逐一存取&lt;/p&gt;
&lt;p&gt;43，系统通过&lt;strong&gt;树形目录结构&lt;/strong&gt;来解决重名问题&lt;/p&gt;
&lt;p&gt;44，在&lt;strong&gt;UNIX操作系统&lt;/strong&gt;中，把&lt;strong&gt;输入输出设备看做特殊文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;45，打开文件操作的主要工作是&lt;strong&gt;把指定的目录复制到内存指定区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;46，&lt;strong&gt;文件路径名&lt;/strong&gt;是指从根目录到该文件所经历的路径中各符号名的集合&lt;/p&gt;
&lt;p&gt;47，按逻辑结构划分，文件主要有两类：记录是文件，流式文件，&lt;strong&gt;文件系统&lt;/strong&gt;的主要目的是实现对文件的&lt;strong&gt;按名存取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;48，连续结构文件必须采用连续分配方式，而链接结构文件和索引结构文件都可采取&lt;strong&gt;离散分配方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;49，文件系统中，若文件的物理结构采用连续结构有关文件的物理位置的信息包括&lt;strong&gt;首块地址和文件长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;50，位示图可用于磁盘空间管理，在文件系统中，为实现文件保护，一般采用&lt;strong&gt;口令，密码和访问控制&lt;/strong&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://tianpingan.github.io/posts/%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E5%A5%BDc%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/" />
            <id>https://tianpingan.github.io/posts/%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E5%A5%BDc%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
            <updated>2021-03-10T15:49:11&#43;08:00</updated>
            <published>0001-01-01T00:00:00&#43;00:00</published>
            <author>
                    <name>TianPingan</name>
                    <uri>https://tianpingan.github.io/</uri>
                    <email>tianpingan2000@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;h2 id=&#34;模块&#34;&gt;模块&lt;/h2&gt;
&lt;p&gt;C 和 C++ 程序基本上都是一些分离编译的&lt;strong&gt;模块&lt;/strong&gt;的集合。得益于分离编译的观念，在编译一个大型项目的可执行文件时，单独重新编译被修改了的模块能提高效率。&lt;/p&gt;
&lt;p&gt;在 C 语言中，&lt;strong&gt;一个模块是由一些结构体，全局变量和函数们组成的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模块 = 结构体 + 全局变量 + 函数&lt;/p&gt;
&lt;p&gt;函数们通常会被定义在源文件中（&lt;code&gt;.c&lt;/code&gt; 文件）。除了&lt;code&gt;main&lt;/code&gt;模块，其他模块的源文件（&lt;code&gt;.c&lt;/code&gt;文件）都会有一个对应的头文件（&lt;code&gt;.h&lt;/code&gt;文件），其中提供了其他模块要使用本模块时所必须的一些声明。&lt;/p&gt;
&lt;p&gt;这么一来其他模块在访问模块 X 时，只要简单地写上&lt;code&gt;#include &amp;quot;X.h&amp;quot;&lt;/code&gt;就行了，链接器会继续完成剩下的工作。除非&lt;code&gt;X.c&lt;/code&gt;文件中的代码被修改了，否则这个文件中的代码只需要一次编译就足够了；剩下的时间里，链接器会将 X 模块的代码链接到最终的可执行文件里而不用再次编译 X 模块，这使得 Unix 下的&lt;code&gt;make&lt;/code&gt;工具和一些 IDE 们能够更有效地工作。&lt;/p&gt;
&lt;p&gt;一个组织良好的 C 程序应当良好地选择（抽象出？）模块，并且适当地构建其头文件，让他能够让人轻松地使用他的功能。这也确保了所有的程序的组件都使用了相同的定义和声明。这对编译器和链接器强制遵守&lt;strong&gt;一次定义规则&lt;/strong&gt;（One Definition Rule）来讲也是非常有帮助的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了尽可能地表述清晰和达到编译上的遍历，你可以按照之下的几条规则来做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则一、每个由&lt;code&gt;.c&lt;/code&gt;和&lt;code&gt;.h&lt;/code&gt;文件组成的模块都应符合清晰的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则二、总是在头文件中使用『包含文件防护』&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则三、把使用本模块需要的声明都放在头文件中，这个文件也常被用来访问此模块。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则四、头文件只包含声明，并且他要在其&lt;code&gt;.c&lt;/code&gt;文件中被导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则五、将外部全局变量的声明使用&lt;code&gt;extern&lt;/code&gt;修饰后放在头文件里，并且把声明定义放在&lt;code&gt;.c&lt;/code&gt;文件中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则六、把模块内部的声明移出头文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则七、每个头文件的都应仅仅导入此头文件所必须的一些头文件，来让这个头文件能够被正确地编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则八、如果仅仅要使用一个未完全声明的结构体，那么就不用导入他对应的头文件了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则九、一个头文件应当能被他自身所成功编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则十、&lt;code&gt;A.c&lt;/code&gt;文件应该最先导入&lt;code&gt;A.h&lt;/code&gt;文件，之后再导入其他所需的头文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则十一、永远不要因为任何原因导入一个&lt;code&gt;.c&lt;/code&gt;文件&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;逐条分析&#34;&gt;逐条分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;规则一、每个由&lt;code&gt;.c&lt;/code&gt;和&lt;code&gt;.h&lt;/code&gt;文件组成的模块都应符合清晰的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从概念上讲，一个模块就是一些可以被一起开发和维护的声明和函数，并假定会在不同的工程中被重用。不要强行合并一些需要被分开来维护的内容，也不要强行分离一些总是要被一起维护的内容。标准库中的&lt;code&gt;math.h&lt;/code&gt;和&lt;code&gt;string.h&lt;/code&gt;就个很明显的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则二、总是在头文件中使用『包含文件防护』&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是与&lt;code&gt;#ifdef&lt;/code&gt;最紧密的例子。选择一个基于头文件名的防护符，这个简单的防护符会确保在一个工程中头文件名总是相互独立的。按照惯例这个防护符是全部大写的。比如&lt;code&gt;Geometry_base.h&lt;/code&gt;文件中就应当以如下内容开头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef GEOMETRY_BASE_H
#define GEOMETRY_BASE_H
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且以如下内容结束&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; #endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作者注：防护符不要以下划线为开头。下划线开头的名字通常为 C 语言内部的一些模块所使用，打破这一规则会造成一些不必要的错误。一下划线开头的规则是相当复杂的，不过只要你记住这一点，你就几乎不会遇到错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则三、把使用本模块需要的声明都放在头文件中，这个文件也常被用来访问此模块。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;code&gt;#include&lt;/code&gt;进来的头文件提供了编译此模块所有必要的信息，并且让链接器能正确地链接它们。此外，如果模块 A 需要使用模块 X 的功能，那么它总是要&lt;code&gt;#include &amp;quot;X.h&amp;quot;&lt;/code&gt;文件，永远不要出现 X 模块中的声明的硬编码。为什么呢？如果 X 模块被修改了，但是你却忘记修改那些 A 模块中那些被硬编码了的声明，那么模块 A 就会出现一些不容易被编译器和链接器发现的&lt;code&gt;run-time&lt;/code&gt;错误。这个种行为违反了&lt;code&gt;One Definition Rule&lt;/code&gt;但是编译器和连接器却又难以发现。总是通过一个模块的头文件来引用模块可以确保只有一处的声明需要被维护，这也对遵守&lt;code&gt;One Definition Rule&lt;/code&gt;有帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则四、头文件只包含声明，并且他要在其&lt;code&gt;.c&lt;/code&gt;文件中被导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把模块中的结构体、函数原型和使用&lt;code&gt;extern&lt;/code&gt;修饰的全局变量的声明放在&lt;code&gt;.h&lt;/code&gt;文件中；把函数的定义和全局变量的定义以及初始化的过程放到&lt;code&gt;.c&lt;/code&gt;文件中。&lt;code&gt;.c&lt;/code&gt;文件必须导入对应的&lt;code&gt;.h&lt;/code&gt;文件；编译器会检查两个文件之间的差异，并确保两个之间的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则五、将外部全局变量的声明使用&lt;code&gt;extern&lt;/code&gt;修饰后放在头文件里，并且把声明定义放在&lt;code&gt;.c&lt;/code&gt;文件中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对有些需要在整个程序中访问的全局变量，把它用&lt;code&gt;extern&lt;/code&gt;修饰后放到头文件中，就像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern int g_number_of_entires;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他模块在使用此模块时只需要导入对应的&lt;code&gt;.h&lt;/code&gt;文件。在模块自身的&lt;code&gt;.c&lt;/code&gt;文件中也要导入相应的&lt;code&gt;.h&lt;/code&gt;文件，并且在文件开头的地方应当出现对应全局变量的声明定义，就像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int g_number_of_entities = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，某些默认为 0 的变量可以被直接当作初始值来使用，静态变量或者全局变量会被自动地初始化成 0。但是显式地初始化成 0 并不是必要的，因为这等于标记这个声明是定义声明，意思就是这个变量的值是唯一的可确定的。注意不同的 C 编译器和链接器可能会允许其他设置全局变量的方式，但是这是被 C++ 的标准所接受的，并且对 C 语言里也是有效的，这也确保了全局变量的&lt;code&gt;One Definiton Rule&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则六、把模块内部的声明移出头文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候模块需要严格使用内部的不被外部所支持的零件来。如果某些结构体声明、全局变量或者函数仅仅在模块内部要被使用到，那就把他们只放在&lt;code&gt;.c&lt;/code&gt;文件的顶部，并且不要在&lt;code&gt;.h&lt;/code&gt;文件中提及它们。此外，使用&lt;code&gt;static&lt;/code&gt;来修饰这些全局变量和函数来关联它们。&lt;/p&gt;
&lt;p&gt;这么做的话，其他模块就不会知道（也无法知道）这些内部的声明、全局变量或者函数。使用&lt;code&gt;static&lt;/code&gt;修饰过的声明会让链接器来强制实施它们内部的关联性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则七、每个头文件的都应仅仅导入此头文件所必须的一些头文件，来让这个头文件能够被正确地编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个头文件到底需要什么呢？如果一个结构体 X 备用来作为这个头文件的中一个结构体中的成员，那么你就必须导入&lt;code&gt;X.h&lt;/code&gt;进来，那么编译器就知道这个 X 结构体到底是谁。不要导入一些仅仅在&lt;code&gt;.c&lt;/code&gt;文件里需要的头文件。&lt;/p&gt;
&lt;p&gt;举个例子的话，&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;就常常被使用在函数的定义中，将他在&lt;code&gt;.c&lt;/code&gt;文件中导入，而不是&lt;code&gt;.h&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则八、如果仅仅要使用一个未完全声明的结构体，那么就不用导入他对应的头文件了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个结构体 X 在结构体声明或函数定义中仅仅出现为一个指针类型，并且代码中不需要访问这个结构体内的成员变量，那么你就不应该导入&lt;code&gt;X.h&lt;/code&gt;，而是在使用它前用一个未完全声明的结构体 X 来代替他（也称做传递声明）。就像下面这样，通过一个指针来引用 X：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct X; /* incomplete (&amp;quot;forward&amp;quot;) declaration */
struct Thing { 
    int i; 
    struct *X x_ptr; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器很乐意接受代码中一个指针指向一个未完全声明的结构体类型，因为指针总是有相同的大小并且只取决于它们指向了什么。典型的就是只有源文件中需要访问 X 结构体的变量或者大小，所以只有&lt;code&gt;.c&lt;/code&gt;文件中需要&lt;code&gt;#include &amp;quot;X.h&amp;quot;&lt;/code&gt;。这是对模块的概括及送耦合化是非常有用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则九、一个头文件应当能被他自身所成功编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个头文件需要显示地导入或者传递一些任何他需要的东西。如果不遵守这个规则的话，在修改所导入的头文件或者被其他头文件所导入时会出现一些令人疑惑的问题。你可以建立一个&lt;code&gt;test.c&lt;/code&gt;并在这个源文件里仅仅导入&lt;code&gt;A.h&lt;/code&gt;来检查这个头文件是否可以被他自身所编译。这里不应该出现任何编译错误。如果发生错误的话说明有些内容需要被导入或者传递声明。测试所有的头文件从导入顺序的底部移到最前面，这会帮助你找到一些与其他头文件的意外的依赖问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则十、&lt;code&gt;A.c&lt;/code&gt;文件应该最先导入&lt;code&gt;A.h&lt;/code&gt;文件，之后再导入其他所需的头文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总是吧&lt;code&gt;#include &amp;quot;A.h&amp;quot;&lt;/code&gt;放在第一位来避免丢失任何其他的所依赖的头文件。之后如果模块&lt;code&gt;A&lt;/code&gt;的代码中需要使用模块&lt;code&gt;X&lt;/code&gt;的话，显式地&lt;code&gt;#include &amp;quot;X.h&amp;quot;&lt;/code&gt;，那么&lt;code&gt;A.c&lt;/code&gt;文件并不是意外地导入&lt;code&gt;X.h&lt;/code&gt;在其他位置。&lt;/p&gt;
&lt;p&gt;并没有一致规定&lt;code&gt;A.c&lt;/code&gt;文件需要再次导入&lt;code&gt;A.h&lt;/code&gt;文件中已经导入的文件，但是有两个建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;X.h&lt;/code&gt;文件在逻辑上不可避免地需要出现在&lt;code&gt;A.h&lt;/code&gt;中，那么在&lt;code&gt;.c&lt;/code&gt;文件中再次被导入是多余的了。所以在&lt;code&gt;A.c&lt;/code&gt;文件中不导入&lt;code&gt;X.h&lt;/code&gt;文件是可以的。&lt;/li&gt;
&lt;li&gt;如果在&lt;code&gt;A.h&lt;/code&gt;文件中&lt;code&gt;#include &amp;quot;X.h&amp;quot;&lt;/code&gt;可以让读者更明确我们在使用 X 模块，并且 A 模块中需要对 X 模块中的某些修改所以来的话就需要在&lt;code&gt;A.c&lt;/code&gt;文件中导入&lt;code&gt;X.h&lt;/code&gt;。举个例子：可能我们已经有一个结构体&lt;code&gt;Thing&lt;/code&gt;了，之后需要摆脱它，但是依然需要在实现的代码中需要他，所以导入这个头文件可以帮助我们摆脱编译错误，那么就可以再次导入&lt;code&gt;X.h&lt;/code&gt;在&lt;code&gt;A.c&lt;/code&gt;文件中。当然，如果&lt;code&gt;X.h&lt;/code&gt;文件不再是必须的了，那么对这个文件的导入语句就应该被删去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;规则十一、永远不要因为任何原因导入一个&lt;code&gt;.c&lt;/code&gt;文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是鲜有发生的，而且总是会把一切都搞乱。为什么会发生这种事呢？因为有时候我们为了维护上的方便而需要把一块代码放到同一个文件中而被其他&lt;code&gt;.c&lt;/code&gt;文件锁共享，所以你把它单独分为一个文件。因为这些代码并不是由一些常规的声明和定义，你知道把他们放在一个头文件里会误导别人，所以你把它放在一个&lt;code&gt;.c&lt;/code&gt;文件里，并且之后用&lt;code&gt;#include &amp;quot;stuff.c&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是这么做会造成其他开发者或编译器的困惑，因为&lt;code&gt;.c&lt;/code&gt;文件应当被分别编译，所以你必须另外告诉其他开发者不要编译这个&lt;code&gt;.c&lt;/code&gt;文件。此外，如果它们丢失了这份难以纪录的点，它们会得到由编译器返回的大量奇怪的问题，让人们困惑它们应该怎么使用你的代码。&lt;/p&gt;
&lt;p&gt;结尾：如果他并不像其他一个正常的头文件或者源文件的话，不要把他们命名成差不多的。&lt;/p&gt;
&lt;p&gt;如果你认为你必须这么做的话，首先确认这部分代码并不能被单独分成一个模块，之后将这个文件使用不一样的后缀名&lt;code&gt;.inc&lt;/code&gt;或者&lt;code&gt;.inl&lt;/code&gt;以来使用他。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
